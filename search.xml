<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[硬盘标称容量为什么比电脑显示的要小?]]></title>
    <url>%2F2018%2F10%2F24%2FHardDiskCapacitySmallerThanDisplayedByComputer%2F</url>
    <content type="text"><![CDATA[玩电脑的人应该都知道一个现象，明明的买 8G U盘，怎么插电脑上就只有7.4点多，16G的只有14.8; 然后同样的事情，也发生在了硬盘上，明明买的是1TB硬盘怎么显示只有931GB呢，今天我就为大家解答一下： 原因很简单，因为电脑本省的二进制的，容量单位的换算呢本来是2的10次方：1024 可是实际上呢，硬盘制造厂商觉得这个数字不好计算，就统一用了一个整数：1000 乍一看 1024换到1000没啥关系，可是看完下面的计算你觉得呢： 因为实际容量的换算和计算机读取的换算是1000/1024的关系，所以容量每升一级，都在缩水 123456789101112131415161718192021222324251000 B = 1KB (1 * 1000 / 1024 = 0.976562 KB) 实际显示 1000 B1000 KB = 1MB （0.976562 * 1000 / 1024 = 0.953674 MB) 实际显示 976 KB1000 MB = 1GB (0.953674 * 1000 / 1024 = 0.931322 GB) 实际显示 953 MB1000 GB = 1TB (0.931322 * 1000 / 1024 = 0.909494 TB) 实际显示 931 GB (目前主流机械硬盘单盘的容量单位 TB )1000 TB = 1PB (0.909494 * 1000 / 1024 = 0.888178 PB) 实际显示 909 TB (目前大型服务器总容量单位 PB )1000 PB = 1EB (0.888178 * 1000 / 1024 = 0.867361 EB) 实际显示 888 PB **【这】** **【毕】**1000 EB = 1ZB (0.867361 * 1000 / 1024 = 0.847032 ZB) 实际显示 867 EB **【些】** **【竟】**1000 ZB = 1YB (0.847032 * 1000 / 1024 = 0.827180 YB) 实际显示 847 ZB **【你】** **【你】**1000 YB = 1BB (0.827180 * 1000 / 1024 = 0.807793 BB) 实际显示 827 YB **【就】** **【现】**1000 BB = 1NB (0.807793 * 1000 / 1024 = 0.788860 NB) 实际显示 807 BB **【不】** **【在】**1000 NB = 1DB (0.788860 * 1000 / 1024 = 0.770371 DB) 实际显示 788 NB **【用】** **【买】**1000 DB = 1CB (0.770371 * 1000 / 1024 = 0.752316 CB) 实际显示 770 DB **【看】** **【不】**1000 CB = 1XB (0.752316 * 1000 / 1024 = 0.734683 XB) 实际显示 752 CB **【了】** **【起】**]]></content>
  </entry>
  <entry>
    <title><![CDATA[科普--固态硬盘那么多怎么选]]></title>
    <url>%2F2018%2F10%2F19%2FHowToChooseSSD%2F</url>
    <content type="text"><![CDATA[笔者第一次接触固态是在13年，那时候固态还很贵，256GB普遍价格都上千的。（请忽略16年9月那一波高价） 当我把自己的笔记本换上固态装上系统 软件，哇塞。。。。。。。真香。那速度简直了，开机变得很快了，开机进入桌面之后再也不像之前那样鼠标还要转好久的圈圈了，直接想开什么开什么，完全没有了老硬盘的那种等待。香的一批。。。。那么现在就来说一下普通用户固态硬盘怎么选。请注意【普通用户】。 首先看接口在这场存储革命中，为了实现更快的速度、更好的体验，SSD的接口也在不断进化革新，像主流的SSD接口就有SATA、M.2、PCI-E、mSATA等。(mSATA这个接口目前来说很不常用，就不介绍了，就是Sata的mini版本，其他数据一模一样)，这3种常见的接口有什么不同？又适合什么样平台使用呢？ 最为常见的SATA接口SATA是Serial ATA的缩写，即串行ATA（俗称的串口） 如图就这货 现时，SATA分别有SATA 1.0 （1.5Gbit/s）、SATA 2.0 （3Gbit/s）、SATA 3.0（6Gbit/s）三种规格；目前主流主板上都是3.0居多，少量2.0，或者干脆没有2.0。从接口速度上我们不难看出，哪怕是现在最快SATA固态也只能有6.0的带宽，根据接口的协议，也只不过550+的传输速度。对比机械已然不慢，但是还不够快。 目前最为流行的M.2接口M.2接口，是Intel推出的一种替代MSATA新的接口规范。 M.2接口是为超极本（Ultrabook）量身定做的新一代接口标准，以取代原来的mSATA接口。无论是更小巧的规格尺寸，还是更高的传输性能，M.2都远胜于mSATA。 M.2接口，是Intel推出的一种替代MSATA新的接口规范。其实，对于桌面台式机用户来讲，SATA接口已经足以满足大部分用户的需求了，不过考虑到超极本用户的存储需求。 发展到现在这类接口的还可以分为两类； M.2 Mkey此类硬盘的外形如下图： M.2 M-Key&amp;B-key 然后看协议这一部分是需要确认你要安装固态硬盘的设备，是否能支持此类协议，因为M.2接口的两个Key，所支持的协议不同，可能会影响使用。接口支持什么协议，什么类型，请查看产品说明书。 M.2 Mkey此类接口一般来说用的是NVMe协议，以PCIE 3.0为例，链接带宽一般为PCIe X4，链接速度是就是32Gbps（4*8） ，换算到数据读写速度就是每秒4GB位上限，不过目前为止达不到，毕竟理论归理论，实际有损耗。 部分PCIe 总线，走PCIE通道，AHCI 协议（三星 SM951A）； PS：部分链接带宽也有PCIe x2的，速度就只有16Gbps，2GB/s，读写速度一般为700-1600 / 500-1000（ADATA SX6000）； M-Key&amp;B-key部分SSD采用SATA总线，使用ACHI协议（三星 850 EVO M.2），大部分都这种； 部分采用NVMe协议，走PCIE通道，不过带宽只有PCIEx2（例如Intel的傲腾内存，金士顿的A1000）； 容量影响速度以intel 760P为例，这是一款 M.2 接口，Nvme协议的高速固态，全速读写数据为3200/1600 MB/s，但是注意这是全速（Up To），最高速，并不是所有容量都这个速度。 这一个型号目前有五个容量： 2.04TB，1.02TB ， 512GB，256GB ，128GB速度如下： 从中可以看出读取速度在256以上差距不大，但是128-256的差距简直天差地别。所以从容量上来建议上256GB起步的容量，毕竟速度快的不是一点半点。 总结 看主板接口 看接口所采用的协议 选自己适合的容量 主要还是看Money 任何抛开预算谈配置的都是耍流氓 相关链接 简书：https://www.jianshu.com/p/0997e3e8df40 CSDN：https://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/83177880 ilongge.cn：http://ilongge.cn/2018/10/19/HowToChooseSSD/]]></content>
      <tags>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科普--新装电脑固态多大合适？]]></title>
    <url>%2F2018%2F10%2F18%2FSSD_Capacity%2F</url>
    <content type="text"><![CDATA[新装电脑固态多大合适2018年在intel 8代U和AMD锐龙的浪潮上，电脑配置和两年前相比高出不少，但是硬盘容量上却提升并不显，可能因为某个大公司手动控制成了了吧。 闲扯淡买电子产品 首先看需求，然后看money。需求明确看钱够不够，不够就降低配置，有钱就加点，千万别一直加，不然加钱加到九万八么？新装电脑固态硬盘是个好东西，必不可少，可是有人说了固态硬盘不安全，事实证明并没有那么不安全，不是还有机械可以加装的么。 选容量容量影响速度以intel 760P为例，这是一款 M.2 接口，Nvme协议的高速固态，全速读写数据为3200/1600 MB/s，但是注意这是全速（Up To），最高速，并不是所有容量都这个速度。 这一个型号目前有五个容量： 2.04TB，1.02TB ， 512GB，256GB ，128GB速度如下： 从中可以看出读取速度在256以上差距不大，但是128-256的差距简直天差地别。所以从容量上来建议上256GB起步的容量，毕竟速度快的不是一点半点。 预算决定配置任何抛开预算谈配置的都是耍流氓，我难道不知道贵的好么？但是 贵 啊。 从目前SSD的售价来看，Sata接口的2.5寸硬盘已然在300级别，512GB也不过550-650上下，相较于之前SSD疯涨的价格低了很多很多，又重新回到了白菜价。而高速的M.2接口，无论是Nvme协议的固态还是Sata的固态价格也都不算高，只比普通Sata固态贵了两成，intel 760P 512GB目前价格在900以内，256GB价格在500以内。所以从价格上来看，256GB 也是个不错的选择，那么如果你说你还多余 也可以选择512GB的。 买电脑 量力而行 首先看需求 然后看预算 结合需求预算选配置 一定不要做加钱党 不然你的电脑会成为贴吧神机 相关链接 简书：https://www.jianshu.com/p/e2e04810ca02 CSDN：https://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/83143612 ilongge.cn：http://ilongge.cn/2018/10/18/SSD_Capacity/]]></content>
  </entry>
  <entry>
    <title><![CDATA[华为手机显示碎片整理图标]]></title>
    <url>%2F2018%2F10%2F17%2FHuaweiSpacecleanner%2F</url>
    <content type="text"><![CDATA[1、下载anyshortcut软件，安装完成界面时打开创建桌面快捷方式权限。 链接:https://pan.baidu.com/s/1q_RzxWL60jcy9BdMGmT7ZA 密码:yfha 2、第一行填 1com.huawei.systemmanager 3、第二行 1com.huawei.systemmanager.spacecleanner.SpacePieceCleanActivity 4、第三行 1com.huawei.systemmanager.spacecleanner.SpacePieceCleanActivity 5、点右上角的扳手，变可在桌面生成图标 相关链接 简书：https://www.jianshu.com/p/b68c11de9860 CSDN：https://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/83109540 ilongge.cn：http://ilongge.cn/2018/10/17/HuaweiSpacecleanner/]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS-TZImagePickerController获取图片视频]]></title>
    <url>%2F2018%2F10%2F16%2FiOS--TZImagePickerControllerDemo%2F</url>
    <content type="text"><![CDATA[TZImagePickerControllerDemo项目介绍TZImagePickerControllerDemo Podfile新增行 'TZImagePickerController'```12使用之前导入头文件 ```#import &lt;TZImagePickerController.h&gt; 使用说明选照片123456789101112//MaxImagesCount 可以选着的最大条目数TZImagePickerController *imagePicker = [[TZImagePickerController alloc] initWithMaxImagesCount:1 delegate:self];// 是否显示可选原图按钮imagePicker.allowPickingOriginalPhoto = NO;// 是否允许显示视频imagePicker.allowPickingVideo = NO;// 是否允许显示图片imagePicker.allowPickingImage = YES;// 这是一个navigation 只能present[self presentViewController:imagePicker animated:YES completion:nil]; 选择照片的回调1234567// 选择照片的回调-(void)imagePickerController:(TZImagePickerController *)picker didFinishPickingPhotos:(NSArray&lt;UIImage *&gt; *)photos sourceAssets:(NSArray *)assets isSelectOriginalPhoto:(BOOL)isSelectOriginalPhoto&#123; &#125; 选视频123456789101112//MaxImagesCount 可以选着的最大条目数TZImagePickerController *imagePicker = [[TZImagePickerController alloc] initWithMaxImagesCount:2 delegate:self];// 是否显示可选原图按钮imagePicker.allowPickingOriginalPhoto = NO;// 是否允许显示视频imagePicker.allowPickingVideo = YES;// 是否允许显示图片imagePicker.allowPickingImage = NO;// 这是一个navigation 只能present[self presentViewController:imagePicker animated:YES completion:nil]; 选择视频的回调123456// 选择视频的回调-(void)imagePickerController:(TZImagePickerController *)picker didFinishPickingVideo:(UIImage *)coverImage sourceAssets:(PHAsset *)asset&#123; &#125; 相关链接 简书：https://www.jianshu.com/p/b1f74db1286a CSDN：https://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/83108282 ilongge.cn：http://ilongge.cn/2018/10/16/iOS--TZImagePickerControllerDemo/]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS--相册视频MOV转MP4]]></title>
    <url>%2F2018%2F10%2F16%2FiOS-MOVConvertToMP4%2F</url>
    <content type="text"><![CDATA[相册视频MOV转MP4最新做的一个功能涉及到了视频的录制、压缩及上传。 根据网上诸多大神的经验，终于算是调通了，但也发现了一些问题，所以把我的经验分享一下。 首先，肯定是调用一下系统的相机或相册， 那么导入哪几个库 就不用我说了吧 打开相册获取视频PHAssetTZImagePickerController 这个库是个好东西 1234TZImagePickerController *imagePickerVc = [[TZImagePickerController alloc] initWithMaxImagesCount:20 delegate:self];imagePickerVc.allowPickingVideo = YES;imagePickerVc.allowPickingImage = NO;[self presentViewController:imagePickerVc animated:YES completion:nil]; 从相册获取到视频PHAsset之后这时的 (PHAsset*)asset其实就是 AVURLAsset类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253-(void)imagePickerController:(TZImagePickerController *)picker didFinishPickingVideo:(UIImage *)coverImage sourceAssets:(PHAsset *)asset&#123; /// 包含该视频的基础信息 PHAssetResource * resource = [[PHAssetResource assetResourcesForAsset: asset] firstObject]; NSString *string1 = [resource.description stringByReplacingOccurrencesOfString:@&quot;&#123;&quot; withString:@&quot;&quot;]; NSString *string2 = [string1 stringByReplacingOccurrencesOfString:@&quot;&#125;&quot; withString:@&quot;&quot;]; NSString *string3 = [string2 stringByReplacingOccurrencesOfString:@&quot;, &quot; withString:@&quot;,&quot;]; NSMutableArray *resourceArray = [NSMutableArray arrayWithArray:[string3 componentsSeparatedByString:@&quot; &quot;]]; [resourceArray removeObjectAtIndex:0]; [resourceArray removeObjectAtIndex:0]; for (NSInteger index = 0; index&lt;resourceArray.count; index++) &#123; NSString *string = resourceArray[index]; NSString *ret = [string stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;]; resourceArray[index] = ret; &#125; NSMutableDictionary *videoInfo = [[NSMutableDictionary alloc] init]; for (NSString *string in resourceArray) &#123; NSArray *array = [string componentsSeparatedByString:@&quot;=&quot;]; videoInfo[array[0]] = array[1]; &#125; NSLog(@&quot;%@&quot;,videoInfo); PHVideoRequestOptions *options = [[PHVideoRequestOptions alloc] init]; options.version = PHImageRequestOptionsVersionCurrent; options.deliveryMode = PHVideoRequestOptionsDeliveryModeAutomatic; WS(weakSelf); PHImageManager *manager = [PHImageManager defaultManager]; [manager requestAVAssetForVideo:asset options:options resultHandler:^(AVAsset * _Nullable asset, AVAudioMix * _Nullable audioMix, NSDictionary * _Nullable info) &#123; StrongSelf(strongSelf); NSString *sizeString = videoInfo[@&quot;size&quot;]; NSArray *array = [sizeString componentsSeparatedByString:@&quot;,&quot;]; CGSize size = CGSizeMake([array[0] floatValue], [array[1] floatValue]); [strongSelf choseVedioCompeletWithVedioAsset:(AVURLAsset *)asset andAVAudioMix:audioMix andVedioInfo:info andImageSize:size]; &#125;];&#125; 为了避免循环引用，这里另写方法调用转码1234567891011121314151617181920- (void)choseVedioCompeletWithVedioAsset:(AVURLAsset *)urlAsset andAVAudioMix:(AVAudioMix *)audioMix andVedioInfo:(NSDictionary *)vedioInfo andImageSize:(CGSize)size&#123; //[self showLoadingView:@&quot;处理视频数据&quot;]; WS(weakSelf); [RecordTools convertMovToMp4FromAVURLAsset:urlAsset andCompeleteHandler:^(NSURL * _Nonnull fileUrl) &#123; StrongSelf(strongSelf); [strongSelf hideLoadingView]; [strongSelf addVideoToTableCompeletWithVedioAsset:urlAsset andAVAudioMix:audioMix andVedioInfo:vedioInfo andImageSize:size andMP4FileUrl:fileUrl]; &#125;]; &#125; 检查视频文件的合规性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//30*1024*1024 B 字节#define VideoSizeMax 31457280- (void)addVideoToTableCompeletWithVedioAsset:(AVURLAsset *)urlAsset andAVAudioMix:(AVAudioMix *)audioMix andVedioInfo:(NSDictionary *)vedioInfo andImageSize:(CGSize)size andMP4FileUrl:(NSURL *)MP4FileUrl&#123; if (MP4FileUrl == nil || MP4FileUrl.path == nil) &#123; showMsg(@&quot;视频获取失败&quot;); return; &#125; AVAssetImageGenerator *generator = [AVAssetImageGenerator assetImageGeneratorWithAsset:urlAsset]; generator.appliesPreferredTrackTransform = YES; generator.maximumSize = CGSizeMake(size.width, size.height); NSError *error = nil; CGImageRef img = [generator copyCGImageAtTime:CMTimeMake(0, 10) actualTime:NULL error:&amp;error]; UIImage *image = [UIImage imageWithCGImage:img]; NSError *mp4Rrror = nil; // 检查文件属性 查看文件大小 是否超标 NSDictionary *infoDict = [[NSFileManager defaultManager]attributesOfItemAtPath:MP4FileUrl.path error:&amp;mp4Rrror]; NSString *fileSizeString = infoDict[@&quot;NSFileSize&quot;]; if (fileSizeString &amp;&amp; !error) &#123; NSInteger fileSize = fileSizeString.integerValue; if (fileSize&gt;VideoSizeMax) &#123; showMsg(@&quot;视频最大不能超过30M&quot;); [[NSFileManager defaultManager] removeItemAtPath:MP4FileUrl.path error:&amp;error]; return; &#125; &#125; else&#123; showMsg(@&quot;视频获取失败&quot;); [[NSFileManager defaultManager] removeItemAtPath:MP4FileUrl.path error:&amp;error]; return; &#125; // 你们不需要 // if (self.lastSelectPath) &#123;// [self.dataArray replaceObjectAtIndex:self.lastSelectPath.row// withObject:@&#123;@&quot;type&quot;:@&quot;vedio&quot;,// @&quot;value&quot;:MP4FileUrl,// @&quot;image&quot;:image&#125;];// &#125;// else&#123;// [self.dataArray addObject:@&#123;@&quot;type&quot;:@&quot;vedio&quot;,// @&quot;value&quot;:MP4FileUrl,// @&quot;image&quot;:image&#125;];// &#125;// // dispatch_async(dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;// // dispatch_async(dispatch_get_main_queue(), ^&#123;// // [self.mainTableView reloadData];// &#125;);// // &#125;);&#125; MOV转码MP412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970+ (void)convertMovToMp4FromAVURLAsset:(AVURLAsset*)urlAsset andCompeleteHandler:(void(^)(NSURL *fileUrl))fileUrlHandler&#123; AVURLAsset *avAsset = [AVURLAsset URLAssetWithURL:urlAsset.URL options:nil]; NSArray *compatiblePresets = [AVAssetExportSession exportPresetsCompatibleWithAsset:avAsset]; if ([compatiblePresets containsObject:AVAssetExportPresetLowQuality]) &#123; // 在Documents目录下创建一个名为FileData的文件夹 NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)lastObject] stringByAppendingPathComponent:@&quot;Cache/VideoData&quot;]; NSFileManager *fileManager = [NSFileManager defaultManager]; BOOL isDir = FALSE; BOOL isDirExist = [fileManager fileExistsAtPath:path isDirectory:&amp;isDir]; if(!(isDirExist &amp;&amp; isDir)) &#123; BOOL bCreateDir = [fileManager createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:nil]; if(!bCreateDir)&#123; NSLog(@&quot;创建文件夹失败！%@&quot;,path); &#125; NSLog(@&quot;创建文件夹成功，文件路径%@&quot;,path); &#125; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;]]; [formatter setDateFormat:@&quot;yyyy_MM_dd_HH_mm_ss&quot;]; //每次启动后都保存一个新的日志文件中 NSString *dateStr = [formatter stringFromDate:[NSDate date]]; NSString *resultPath = [path stringByAppendingFormat:@&quot;/%@.mp4&quot;,dateStr]; NSLog(@&quot;file path:%@&quot;,resultPath); NSLog(@&quot;resultPath = %@&quot;,resultPath); AVAssetExportSession *exportSession = [[AVAssetExportSession alloc] initWithAsset:avAsset presetName:AVAssetExportPresetMediumQuality]; exportSession.outputURL = [NSURL fileURLWithPath:resultPath]; exportSession.outputFileType = AVFileTypeMPEG4; exportSession.shouldOptimizeForNetworkUse = YES; [exportSession exportAsynchronouslyWithCompletionHandler:^(void) &#123; switch (exportSession.status) &#123; case AVAssetExportSessionStatusUnknown: NSLog(@&quot;AVAssetExportSessionStatusUnknown&quot;); fileUrlHandler(nil); break; case AVAssetExportSessionStatusWaiting: NSLog(@&quot;AVAssetExportSessionStatusWaiting&quot;); fileUrlHandler(nil); break; case AVAssetExportSessionStatusExporting: NSLog(@&quot;AVAssetExportSessionStatusExporting&quot;); fileUrlHandler(nil); break; case AVAssetExportSessionStatusCompleted: NSLog(@&quot;AVAssetExportSessionStatusCompleted&quot;); fileUrlHandler(exportSession.outputURL); break; case AVAssetExportSessionStatusFailed: NSLog(@&quot;AVAssetExportSessionStatusFailed&quot;); fileUrlHandler(nil); break; case AVAssetExportSessionStatusCancelled: NSLog(@&quot;AVAssetExportSessionStatusCancelled&quot;); fileUrlHandler(nil); break; &#125; &#125;]; &#125;&#125; 请注意上段代码请不要在模拟器上执行，哪怕你模拟器相册导入了视频也不要，因为 1[AVAssetExportSession exportPresetsCompatibleWithAsset:avAsset]; 没反应！！！！ 这句话是其他帖子没写过的，可能他们没有在模拟器执行过，模拟器是可以导入视频和图片的，直接拖进去就OK。 相关链接 简书：https://www.jianshu.com/p/599b136d9de9 CSDN：https://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/83069071 ilongge.cn：http://ilongge.cn/2018/10/16/iOS-MOVConvertToMP4/]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS--AVAudioRecorder如何录制MP3]]></title>
    <url>%2F2018%2F10%2F16%2FiOS-AVAudioRecorderMP3%2F</url>
    <content type="text"><![CDATA[AVAudioRecorder简介录音机，提供了在应用程序中的音频记录能力。作为与 AVAudioPlayer 相对应的 API，AVAudioRecorder 是将音频录制为文件的最简单的方法。除了用一个音量计接受音量的峰值和平均值以外，这个 API 简单粗暴，如果你的使用场景很简单的话，这可能恰恰就是你想要的方法。 录音配置创建AVAudioSession想要录音首先要创建一个AVAudioSession，这个通道用来调用录音设备； 1234567891011121314151617AVAudioSession *session = [AVAudioSession sharedInstance];NSError *sessionError;[session setCategory:AVAudioSessionCategoryPlayAndRecord error:&amp;sessionError];if(session == nil)&#123; NSLog(@&quot;Error creating session: %@&quot;, [sessionError description]); &#125;else&#123; [session setActive:YES error:nil]; &#125; 创建录音设置字典想要录音 总得配置点啥吧 12345678910111213141516171819202122NSMutableDictionary *audioSetting = [NSMutableDictionary dictionary]; // 设置录音格式 kAudioFormatMPEGLayer3设置貌似是没用的 默认设置就行//[audioSetting setObject:@(kAudioFormatMPEGLayer3) forKey:AVFormatIDKey];// 设置录音采样率，8000 44100 96000，对于一般录音已经够了[audioSetting setObject:@(22150) forKey:AVSampleRateKey];// 设置通道 1 2[audioSetting setObject:@(1) forKey:AVNumberOfChannelsKey];// 每个采样点位数,分为8、16、24、32[audioSetting setObject:@(16) forKey:AVLinearPCMBitDepthKey];// 是否使用浮点数采样 如果不是MP3需要用Lame转码为mp3的一定记得设置NO！(不然转码之后的声音一直都是杂音)// 是否使用浮点数采样 如果不是MP3需要用Lame转码为mp3的一定记得设置NO！(不然转码之后的声音一直都是杂音)// 是否使用浮点数采样 如果不是MP3需要用Lame转码为mp3的一定记得设置NO！(不然转码之后的声音一直都是杂音)[audioSetting setObject:@(YES) forKey:AVLinearPCMIsFloatKey];// 录音质量[audioSetting setObject:@(AVAudioQualityHigh) forKey:AVEncoderAudioQualityKey]; 创建一个录音文件的存放路径录完音总得给个地方存吧 123456789101112131415161718192021222324252627282930313233// 在Documents目录下创建一个名为FileData的文件夹NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)lastObject] stringByAppendingPathComponent:@&quot;Cache/AudioData&quot;];NSLog(@&quot;%@&quot;,path);NSFileManager *fileManager = [NSFileManager defaultManager];BOOL isDir = FALSE;BOOL isDirExist = [fileManager fileExistsAtPath:path isDirectory:&amp;isDir];if(!(isDirExist &amp;&amp; isDir)) &#123; BOOL bCreateDir = [fileManager createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:nil]; if(!bCreateDir)&#123; NSLog(@&quot;创建文件夹失败！&quot;); &#125; NSLog(@&quot;创建文件夹成功，文件路径%@&quot;,path);&#125; //每次启动后都保存一个新的文件中NSDateFormatter *formatter = [[NSDateFormatter alloc] init];[formatter setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;]];[formatter setDateFormat:@&quot;yyyy_MM_dd_HH_mm_ss&quot;]; NSString *dateStr = [formatter stringFromDate:[NSDate date]];// 想要录制MP3格式的 这里 MP3 必须大写 ！！！！(苹果的所有后缀名都是大写，所以这是个坑)// 想要录制MP3格式的 这里 MP3 必须大写 ！！！！(苹果的所有后缀名都是大写，所以这是个坑)// 想要录制MP3格式的 这里 MP3 必须大写 ！！！！(苹果的所有后缀名都是大写，所以这是个坑)path = [path stringByAppendingFormat:@&quot;/%@.MP3&quot;,dateStr];NSLog(@&quot;file path:%@&quot;,path);NSURL *url=[NSURL fileURLWithPath:path]; 录音完整操作1234567891011121314151617181920212223242526272829303132//如果是在录音就不做动作if ([self.audioRecorder isRecording]) &#123; return;&#125;//创建录音通道[self setAudioSession];//创建录音格式设置NSDictionary *setting = [self getAudioSetting];//创建录音文件保存路径NSURL *url = [self getSavePath];//创建录音机NSError *error=nil;self.audioRecorder=[[AVAudioRecorder alloc]initWithURL:url settings:setting error:&amp;error];self.audioRecorder.delegate=self;self.audioRecorder.meteringEnabled=YES;//如果要监控声波则必须设置为YESif (error) &#123; NSLog(@&quot;创建录音机时发生错误，信息：%@&quot;,error.localizedDescription);&#125;else&#123; if (![self.audioRecorder isRecording]) &#123; NSLog(@&quot;录音开始&quot;); [self.audioRecorder record]; &#125;&#125; 相关链接 简书：https://www.jianshu.com/p/ce8149399df2 CSDN：https://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/83068382 ilongge.cn：http://ilongge.cn/2018/10/16/iOS-AVAudioRecorderMP3/]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS--DeviceSupport(持续更新)]]></title>
    <url>%2F2018%2F09%2F21%2FiOS-DeviceSupport%2F</url>
    <content type="text"><![CDATA[iOS–DeviceSupport(持续更新)12.1 (16B5059d) 2018年9月20号更新 百度云链接：12.1 (16B5059d) 12.0 (16A366) 2018年9月18号更新 百度云链接：12.0 (16A366) 12.0 (16A5308d) 2018年6月29号更新 百度云链接：12.0 (16A5308d) 12.0 (16A5288q) 2018年6月29号更新 百度云链接：12.0 (16A5288q) 11.4 2018年6月26号更新 百度云链接：11.4 11.3 (15E217) 2018年4月23号更新 百度云链接：11.3 (15E217) 相关链接 简书：https://www.jianshu.com/p/e365df8749f3 CSDN：https://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/82795731 ilongge.cn：http://ilongge.cn/2018/09/21/iOS-DeviceSupport/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Xcode10：library not found for -lstdc++.6.0.9 临时解决]]></title>
    <url>%2F2018%2F09%2F18%2FMac--Xcode10_library_not_found_for_-lstdc%2B%2B_6_0_9%2F</url>
    <content type="text"><![CDATA[Xcode10：library not found for -lstdc++.6.0.9 临时解决下载stdc++.6.0.9提取自Xcode9 百度云链接：stdc++.6.0.9 部分项目依赖 libstdc++.6.0.9 的会在Xcode 10无法运行 其原因是Xcode 10中将libstdc++.6.0.9库文件删除，原本功能迁移至其他库 真机运行库在终端输入以下命令打开Xcode的lib库目录（此目录位安装的默认目录） 1open /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib 如果安装在其他目录 或者Xcode改名的建议右键Xcode显示报内容，进入 1Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib 把刚刚下载的zip文件解压 获取到的 真机的 libstdc++.6.0.9.tbd 文件，扔进去 模拟器运行库在终端输入以下命令打开Xcode的lib库目录（此目录位安装的默认目录） 1open /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib 如果安装在其他目录 或者Xcode改名的建议右键Xcode显示报内容，进入 1Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib 把刚刚下载的zip文件解压 获取到的 模拟器的 libstdc++.6.0.9.tbd 文件，扔进去 下一步重启Xcode 相关链接 简书： https://www.jianshu.com/p/76bd060bab34 CSDN：https://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/82756116]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS--WKWebView Cookie注入]]></title>
    <url>%2F2018%2F09%2F12%2FiOS-WKWebView-Cookie%2F</url>
    <content type="text"><![CDATA[WKWebView Cookie注入在一些项目中我们需要通过webView来访问内容，那么就可能用到cookie，今天就来说一下，在iOS开发中如何向webView中注入cookie。 设置cookie内容12345678910111213141516/// 创建cookie 此处只为示例let cookieString = &quot;document.cookie=&apos;cookie&apos;&quot;/// 注入cookielet userScript = WKUserScript.init(source: cookieString, injectionTime: .atDocumentStart, forMainFrameOnly: false) let userController = WKUserContentController.init()userController.addUserScript(userScript)webViewConfig.userContentController = userControllerwebView = WKWebView.init(frame: frame, configuration: webViewConfig) 其中 ‘cookie’ 具体为你当前所在项目或者所需要的功能需要的内容， 一般的会是 Key=Value 结构，每对键值对需要要 ‘;’ 来隔开。 举个例子某个项目cookie需要上传用户的token， 并且规定了token的key为固定的一段字符串：”abcdefg” 并且cookie的域名设置为根目录： / cookie的域名为：baidu.com 那么最后生成的Cookie就是 ‘abcdefg=token;Path=/;Domain=baidu.com;’ 然后代码上就这么写 12/// 创建cookie字符串let cookieString = &quot;document.cookie=&apos;abcdefg=token;Path=/;Domain=baidu.com;&apos;&quot; 简书：https://www.jianshu.com/p/9e18d889ba0b CSDN：https://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/82658967]]></content>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods_多版本共存]]></title>
    <url>%2F2018%2F08%2F16%2FCocoapods-Multiversion%2F</url>
    <content type="text"><![CDATA[安装和单版本安装一致 使用不指定版本(默认最新版本运行command) 1pod command 指定版本 12pod _版本号_ command# eg: pod _1.5.3_ update]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac_Hexo_Blog]]></title>
    <url>%2F2018%2F08%2F16%2FMac-Hexo-Blog%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[制作Mac引导盘]]></title>
    <url>%2F2018%2F04%2F07%2FMac--Make-Boot-USB-Disk-For-Mac%2F</url>
    <content type="text"><![CDATA[如何制作Mac引导盘制作mac的引导盘方法不止这一种，请严格按照要求来操作，出毛病我是不负责的哦。 准备工作 8GB U盘一个（这个是容量下限，最低8GB，最好是USB3.0或者以上） 一个正常使用的macOS 下载原版系统 (已下载可以忽略) 打开AppStore 看AppStore窗口右侧 macOS ······ 点击 下载 等（这个看网速的） 制作引导盘【注意】每个输入都和之前的一句隔着一个 空格 打开终端（terminal） 输入 “sudo” 1sudo 打开Finder（新版系统叫访达） 进入应用程序 点击刚刚下载的系统 右键–显示包内容 找到路径“Contents/Resources/createinstallmedia”，直接拖至终端,然后代码应该是下面这种 12sudo /Applications/Install\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia 注意 sudo 后有 空格 接着输入以下代码 12--volume 语句现在是这样的 12sudo /Applications/Install\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia --volume 然后输入你的U盘盘符 12/Volumes/macOS 语句现在是这样的 12sudo /Applications/Install\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS 下一步 (macOS 10.14 跳过此段命令) 12--applicationpath 语句现在是这样的 12sudo /Applications/Install\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS --applicationpath 下一步 直接把应用程序内的“安装macOS High Sierra.app”拖进终端 语句现在是这样的 12sudo /Applications/Install\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS --applicationpath /Applications/Install\ macOS\ High\ Sierra.app 下一步 12--nointeraction 语句现在是这样的 12sudo /Applications/Install\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/macOS --applicationpath /Applications/Install\ macOS\ High\ Sierra.app --nointeraction 回车 （提示输入密码） 12Password: 输入管理员密码 回车 正在格式化磁盘 12Erasing Disk: 0%... 10%... 20%... 30%...100%... 正在拷贝安装器文件 12Copying installer files to disk... 这个时候你就可以看到你的U盘名称变了，而且里面多了一个系统，不过这个时候并没有完成 大概需要等待5-10分钟，这个时间长短主要取决于你U盘的写入速率 当显示下面信息是就代表制作完成 123456Copy complete.Making disk bootable...Copying boot files...Copy complete.Done.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Computer--U盘引导盘制作工具集合]]></title>
    <url>%2F2018%2F04%2F05%2FComputer--PE_Boot_USB_Disk_Tools_Set%2F</url>
    <content type="text"><![CDATA[写作目的为了向电脑小白科普目前，使用人数较多的PE引导盘的制作工具软件，这玩意的用处真的是很大很大了。 千万不要说PE只能重装系统。 新硬盘无操作系统无分区，需要PE。 系统忘记登录密码不想重装，需要PE。 系统崩溃还有资料在桌面或者C盘，需要PE。 全盘数据恢复，需要PE。 重建主引导记录（MBR），重建分区表（修复分区表）、修复Windows系统引导，需要PE。 这么有用的东西到底有多少呢，我也不是很清楚，看看下面就知道了。（排名不分先后，想到哪个写哪个） 电脑店这个是我第一次用的制作工具，不知道怎么就给找到了。使用电脑店制作U盘PE系统比较的简单，基本上一键即可轻松制作，支持多种启动模式选择，支持个性化设置，别小看这个个性化设置，里边还隐藏着一些奥妙，为了测试的需要，我们采用默认设置进行PE系统的制作。 电脑店U盘启动盘制作工具，也是常称为的U盘启动制作工具的功能升格版，能更方便电脑技术人员装机、维护电脑使用的超强工具。此作品制作简单，支持所有U盘一键制作成启动盘；兼容多种机型；支持GHO、ISO系统文件，更支持原版系统安装，集成更全面工具，完全可以应对电脑技术人员常见的电脑故障维护工作。 主页：电脑店 - - &gt; http://u.diannaodian.com/ U深度这个是我比较喜欢里面的傲梅分区助手 主页：U深度 - - &gt; http://www.ushendu.info/ 大白菜基本和电脑店差不多，大白菜制作U盘PE系统同样简单，还是一键即可搞定，也支持多种启动模式选择，支持个性化设置，个性化设置里同样隐藏着一些东西，可以自己去研究。 老牌经典PE之一，同时集成服务器版的server 2003和win8PE，支持BIOS/UEFI双启，对古董机器兼容非常好。内置工具比微PE多。集成一键装机，硬盘数据恢复，密码破解，等等实用的程序。 但是个人觉得部分工具重复，工具版本偏老旧、且略为臃肿。另！大白菜PE制作时要事先取消360赞助，否则安装系统后将装上360，不介意用户请忽略。 我觉得大白菜亮点是支持读写苹果分区格式（注意是读写，不是读取！），非常适合黑苹果用户。我也是个黑苹果用户。 主页：大白菜 - - &gt; http://www.dabaicaipe.cn/dbcpe/ 老毛桃基本和电脑店差不多 主页：老毛桃 - - &gt; http://www.laomaotao.org/]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows--验证SHA1 MD5值]]></title>
    <url>%2F2018%2F04%2F01%2FWindows--How_to_verify_the_SHA1_MD5_value%2F</url>
    <content type="text"><![CDATA[日常使用电脑过程中，难免会下载很多文件，比如游戏，软件等等，很多人在下载一个耗时长而又速度不稳定的文件之后，都可能遇见打开文件的时候显示文件被损坏的情况，这时候我们就需要在下载完成之后对文件就行数据完整性校验了。 举个例子，以验证系统的记事本程序的Hash值为例，程序文件的路径为C:\Windows\notepad.exe。如果我们想要校验它的MD5值，Win7 可运行： MD5 1certutil -hashfile C:\Windows\notepad.exe MD5 SHA1 1certutil -hashfile C:\Windows\notepad.exe SHA1 SHA256 1certutil -hashfile C:\Windows\notepad.exe SHA256 上面MD5 SHA1 SHA256请不要小写，除了文件路径，其他的要和上面一模一样 Win10 可运行如下命令： Get-FileHash C:\Windows\notepad.exe -Algorithm MD5| Format-List 如果想要校验它的SHA1值，则运行如下命令： Get-FileHash C:\Windows\notepad.exe -Algorithm SHA1| Format-List 如果想要校验SHA256值，则不需要带-Algorithm参数即可，命令如下： Get-FileHash C:\Windows\notepad.exe | Format-List 上面这个文件的路径是可以直接由鼠标拖进去的]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何下载Windows系统]]></title>
    <url>%2F2018%2F04%2F01%2FWindows--Download_Windows_Image%2F</url>
    <content type="text"><![CDATA[本文主要讲述如何下载原版系统，所谓的原版系统就是微软服务器上的系统镜像，而不是国内各大论坛的GHOST版本，个人并不推荐GHOST以及其他任何第三方封装过的系统。以下载win10 1511中文简体64位为例子 第1步 进入MSDN 网址为http://msdn.itellyou.cn/ 第2步 选择操作系统 第3步 选择你需要的系统版本 windows 10，Version 1511 中文-简体 64位 （X64） 第4步 复制ed2k链接 第5步 打开下载工具，新建一个下载任务，链接就是用刚才复制的链接 下载中最好不要暂停 下载完了之后记得验证SHA1值]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多站点配置SSH-Key]]></title>
    <url>%2F2018%2F03%2F14%2FMultWWWConfigSSH-Key%2F</url>
    <content type="text"><![CDATA[多站点配置SSH-Key相信很多用mac在开发的同学都会遇见一个问题：会根据业务不同往不同的git服务器上提交代码。这些库有私有的有公有的，这时候就需要配置SSH_Key了。 生成SSH-Key打开终端 （terminal） gitee(码云) · 秘钥对使用以下命令生成gitee的秘钥对【注意】emailaddress 填写自己的邮件地址 1ssh-keygen -t rsa -C &quot;emailaddress&quot; -f ~/.ssh/gitee_id_rsa github · 秘钥对使用以下命令生成github的秘钥对【注意】emailaddress 填写自己的邮件地址 1ssh-keygen -t rsa -C &quot;emailaddress&quot; -f ~/.ssh/github_id_rsa 添加私钥这个步骤是把私钥添加到当前设备，本地的不需要网络 添加 gitee 私钥 1ssh-add ~/.ssh/gitee_id_rsa 添加 github 私钥 1ssh-add ~/.ssh/github_id_rsa 添加公钥 和私钥不一样的是公钥是添加到git服务器的，所以这操作主要是在网页上进行的 添加 gitee 公钥显示出gitee的公钥 1cat ~/.ssh/gitee_id_rsa.pub 将展示出的以ssh-rsa开头，然后以刚才你输入的emailaddress结尾的内容全部复制 添加至gitee的SSHKey公钥 添加 github 公钥显示出github的公钥 1cat ~/.ssh/github_id_rsa.pub 将展示出的以ssh-rsa开头，然后以刚才你输入的emailaddress结尾的内容全部复制 添加至github的SSHKey公钥 创建Config在 ~/.ssh/目录下创建一个配置文件，来为秘钥使用做配置 1cd ~/.ssh/ 使用vim命令进行config文件的创建和编辑 1vim config 然后文件写入以下内容 添加以下内容12345678910# giteeHost gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitee_id_rsa# githubHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github_id_rsa 然后配对秘钥主要测试当前秘钥是否可用 配对gitee秘钥1ssh -T git@gitee.com gitee的测试会让输入 yes 连接gitee成功之后会显示以下信息 Welcome to Gitee.com, yourName! 配对github秘钥1ssh -T git@github.com 连接github成功之后会显示以下信息 Hi yourName! You’ve successfully authenticated, but GitHub does not provide shell access.]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac--苹果笔记本安装Win]]></title>
    <url>%2F2018%2F03%2F11%2FMac--%E8%8B%B9%E6%9E%9C%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85Win%2F</url>
    <content type="text"><![CDATA[Mac–苹果笔记本安装Win(价值200块)为什么说是价值200块呢？ 是因为你拿着你的mac去任何一个电脑店让老板给您装Windows系统，应该会找你要200。 另外本文主要讲述的Windows系统为最新版的Win10 1709版本。 1、因为他们都觉得买得起mac的不差这200块钱。 2、还有一个原因就是因为mac贵，所以我提供的服务也贵。 3、以上两条都是为了坑点钱，其实给mac装Win系统很简单。 比我给windows装mac简单多了。 首先下载一个Windows的ISO镜像文件如果不会参看如何下载Windows系统 使用bootcamp把系统写入到U盘 请注意，下载好的系统最好放在mac上 这里你需要一个最小8GB的U盘，里面要是空的，因为要格式化，有数据的注意备份。 然后插U盘到MAC上。 打开bootcamp(新版系统叫 启动转换助理 ) 继续 勾选三个钩（win7第一个可以不钩） 继续 选择你刚才下载好的ISO系统文件 继续 等 分区，大小可以用鼠标挪动 重启就开始安装了 安装Windows具体步骤参看【UEFI引导安装Win10】 注意 选择安装盘的这一步具体操作如下： 选择带有bootcamp的分区，应该是第三个 或者 第四个（选择完成之后下方会有警告提示：不能安装到当前分区。。。。。。） 然后点击下方格式化（请确认上一步硬盘是否选错） 格式化之后，第一步的警告提示就应该消失了 下一步 其他步骤基本无异 再次重启进入Windows之后，打开U盘中的bootcamp.exe安装上去。这个文件是苹果电脑的驱动支持软件，不装的话估计你连网都没有哦。 是不是很简单完！]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何将硬盘分区表转换为GUID(GPT)分区表]]></title>
    <url>%2F2018%2F02%2F26%2FWindows--The_Hard_Disk_Partition_Table_Type_changge_To_GUID(GPT)%2F</url>
    <content type="text"><![CDATA[如何将硬盘分区表转换为GUID(GPT)分区表如果不知道自己的硬盘分区表类型可以参看 Windows–如何查看硬盘分区表类型 1、使用PE 制作U盘PE启动盘 进入PE 在PE里打开磁盘精灵 （DG） 右键磁盘 菜单中有转换为GUID分区表 2、在安装Win的时候 制作UEFI启动盘 进入UEFI安装的界面 shift + F10 （打开终端） 输入diskpart 回车 （进入diskpart） list disk (显示磁盘列表，注意这里你只能用大小来区分你的硬盘了) sel disk 0 (这个编号你自己看着你的来) clean （清除数据）（可选） convert gpt (转换为GPT分区表，好像是会清除磁盘上数据的) 同理，GPT转换至MBR上述方法同样适用]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows--如何查看硬盘分区表类型]]></title>
    <url>%2F2018%2F02%2F24%2FWindows--View_The_Hard_Disk_Partition_Table_Type%2F</url>
    <content type="text"><![CDATA[如何查看硬盘分区表类型1、什么是硬盘分区表人们在使用电脑时，有时由于异常操作，有时由于病毒侵袭，会导致某个分区消失或硬盘无法启动。究其原因，就是硬盘分区表受损。硬盘分区表可以说是支持硬盘正常工作的骨架。操作系统正是通过它把硬盘划分为若干个分区，然后再在每个分区里面创建文件系统，写入数据文件。本文主要讲述的是分区表的位置，结构以及各个分区表是如何链接起来的。当掌握了这些知识后，即使分区表受到破坏，一样也可以根据残存的数据手工修复分区表，从而修复分区。 2、都有什么类型目前在用的 分区表类型主要有了两个： GUID （也叫 GPT）一种由基于 Itanium 计算机中的可扩展固件接口 (EFI) 使用的磁盘分区架构。与主启动记录(MBR) 分区方法相比，GPT 具有更多的优点，因为它允许每个磁盘有多达 128 个分区，支持高达 18 千兆兆字节的卷大小，允许将主磁盘分区表和备份磁盘分区表用于冗余，还支持唯一的磁盘和分区 ID (GUID）。与支持最大卷为 2 TB (terabytes) 并且每个磁盘最多有 4 个主分区（或 3 个主分区，1 个扩展分区和无限制的逻辑驱动器）的主启动记录(MBR)磁盘分区的样式相比，GUID分区表 (GPT) 磁盘分区样式支持最大卷为 18 EB (exabytes) 并且每磁盘最多有 128 个分区。与MBR分区的磁盘不同，至关重要的平台操作数据位于分区，而不是位于非分区或隐藏扇区。另外，GPT 分区磁盘有多余的主要及备份分区表来提高分区数据结构的完整性。 MBR传统的分区方案（称为MBR分区方案）是将分区信息保存到磁盘的第一个扇区（MBR扇区）中的64个字节中，每个分区项占用16个字节，这16个字节中存有活动状态标志、文件系统标识、起止柱面号、磁头号、扇区号、隐含扇区数目（4个字节）、分区总扇区数目（4个字节）等内容。由于MBR扇区只有64个字节用于分区表，所以只能记录4个分区的信息。这就是硬盘主分区数目不能超过4个的原因。后来为了支持更多的分区，引入了扩展分区及逻辑分区的概念。但每个分区项仍用16个字节存储。MBR分区方案不是用得好好的吗？为什么要提出新的方案呢？那就让我们看看MBR分区方案有什么问题。前面已经提到了主分区数目不能超过4个的限制，这是其一，很多时候，4个主分区并不能满足需要。另外最关键的是MBR分区方案无法支持超过2TB容量的磁盘。因为这一方案用4个字节存储分区的总扇区数，最大能表示2的32次方的扇区个数，按每扇区512字节计算，每个分区最大不能超过2TB。磁盘容量超过2TB以后，分区的起始位置也就无法表示了。在硬盘容量突飞猛进的今天，2TB的限制将很快被突破。由此可见，MBR分区方案已经无法满足需要了。 3、怎么查看自己的硬盘分区表桌面–&gt;计算机图标–&gt;右键–&gt;管理–&gt;磁盘管理–&gt;选择一个磁盘（注意是磁盘不是分区）–&gt;右键–&gt;属性–&gt;鼠标左键点击“卷”–&gt;查看“磁盘分区形式”]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows--UEFI引导安装Win10]]></title>
    <url>%2F2018%2F02%2F03%2FWindows--UEFI_Boot_Installation_Win10%2F</url>
    <content type="text"><![CDATA[Windows–UEFI引导安装Win10本文主要讲述如何使用普通U盘UEFI引导启动盘安装Windows系统 注意此方法只能安装于GPT(GUID)分区表的硬盘 准备工作 找一个8GB或更大的U盘 USB3.0更好 这样更快 下载官方ISO系统文件镜像（随便找一个不是C盘的目录放着就行，建议直接扔在D盘根目录） 然后新建一个文件夹叫 WindowsImage 解压这个ISO文件到 WindowsImage文件夹 首先制作UEFI启动盘 U盘格式化为Fat32文件系统（有些主板也支持NTFS，比如我的华硕Z170AR） 将解压好的 WindowsImage文件夹下面的所有文件放入U盘跟目录 注意现在的U盘打开之后应该有好几个文件夹，如下图 选择U盘启动 U盘插在需要装系统的电脑上，然后开机 笔记本：自己去百度你的这个型号如何从U盘启动 台式机：去百度你这个电脑主板的U盘启动方法 看图了正式安装系统下一步 现在安装 随便选一个版本 接受 （不然你还想怎样） 自定义 ： 分区自己看着选这一步建议大家把电脑上除了需要装系统的硬盘 其他的都拆下来 没区分的自己分区 没有引导分区会额外自动创建 点击确定 选择系统安装的盘符 基本就是第一个主分区 下一步 等 还是等 重启的时候就可以把U盘拔下来了，因为U盘的作用已经完了 重启 系统设置中国 随便选 我选拼音 随便 我选跳过 等 针对个人使用 下一步 如果不使用微软账号 就找到左下角 脱机账户 否 名字自己起 密码 填不填都可以 我不喜欢 我选否 我就这样配置 等咯 接着等 这不就OK了 完]]></content>
  </entry>
  <entry>
    <title><![CDATA[Centos7配置yum源]]></title>
    <url>%2F2018%2F01%2F12%2FCentos7%E9%85%8D%E7%BD%AEyum%E6%BA%90%2F</url>
    <content type="text"><![CDATA[Centos7配置yum源我们安装完成CentOS系统，默认都是系统自带的yum源，因为你懂得原因会导致国内用户用yum安装软件的时候比较慢，为了提高效率，一般我们会配置国内的yum源。 目前国内比较好的yum源有网易yum源、搜狐yum源等，现在介绍下怎么配置网易163yum源： 1、首先备份/etc/yum.repos.d/CentOS-Base.repo(不一定是这个名称 你可以看一下 具体叫啥) 1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 2、根据CentOS不同版本选择下载对应的repo文件，放到/etc/yum.repos.d/ 目录首先进入yum.repos.d目录1cd /etc/yum.repos.d/ CentOS 5.x1wget http://mirrors.163.com/.help/CentOS5-Base-163.repo CentOS 6.x1wget http://mirrors.163.com/.help/CentOS6-Base-163.repo CentOS 7.x1wget http://mirrors.163.com/.help/CentOS7-Base-163.repo 3、最后，执行yum makecache生成缓存清除缓存1yum clean all 生成新缓存1yum makecache OK, 简单3步操作即可配置完成。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows--如何修改IP地址]]></title>
    <url>%2F2018%2F01%2F11%2FWindows--How_To_Change_IP_Address%2F</url>
    <content type="text"><![CDATA[Windows–如何修改IP地址本文主要讲述windows 7如何修改电脑的IP地址。其他的例如win8 win8.1，win10 基本都一样，如果找不到那么就去搜索控制面板，然后进入网络与Internet 进入网络与共享中心 进入网络适配器页面 进入连接属性 进入ipv4协议属性 手动填写IP地址 这里面的东西如何填写需要根据你的路由器来决定的，基本上家里的设置都是192.168.1. ( 号填写100-254) 子网掩码 基本都是255.255.255.0 网关也是根据路由器来 192.168.1.1 DNS 第一行也可以根据路由器来：192.168.1.1 或者 指定固定的DNS，比如114.114.114.114 第二行随意 保存]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[台式组装机简单故障的排查与清除]]></title>
    <url>%2F2018%2F01%2F10%2FComputer--Normal_Problem_Check_And_Fix%2F</url>
    <content type="text"><![CDATA[台式组装机简单故障的排查与清除本文主要讲述台式机部分简单故障的排查与清除。 故障一：不能正常开机此故障在电脑使用中最为常见，原因也是五花八门，下面我给大家梳理一些常见的故障以及清除方法： 电脑开机，反复重启这种问题十有八九就是内存的问题，下图就是内存：目前主流内存有DDR3和DDR4 如果有空闲的内存插槽，请尝试调整内存安装位置；如不能解决下一条。 如果无法调整位置，请尝试使用橡皮擦蘸酒精擦拭内存金手指位置；如不能解决下一条。 如果无法调整位置，请尝试交换内存安装位置；如不能解决下一条。 如果无法调整位置，请尝试选择拆卸内存，然后每装一根开机一次看看问题是否得到解决，如果确定问题内存建议联系卖家；如不能解决下一条。 实在无法解决请更换内存； 此问题目前我多见于威刚内存 电脑开机主机启动正常，但显示器无反应 这种问题可能是内存的问题，也可能是显卡问题，下图就是显卡：目前主流显卡很多，AMD的 RX 400、RX 500系列，Nvidia的 GTX 9 、GTX 10系列； 如果是NVIDIA的10系显卡，请不要使用不带芯片的VGA转接头，尽量使用HDMI线连接显示器； 按照上个故障来排查；如不能解决下一条。 使用核显，将独立显卡从主板中拆除，将原先插在独立显卡上的视频线接到主板上，如果无相应插头建议自行寻找转换接口，如能正常开机则问题出在显卡上，建议联系卖家； 电脑开机自动进入BIOS这种问题基本就是电脑的启动项设置不对造成的。 进入电脑主板BIOS，进入启动设置：（没错的话叫 BOOT），选择自己系统所在的硬盘作为首选启动项，保存并退出。如不能解决下一条。 如出系统盘外还有其他硬盘请拆除后开机，看看是否正常。 电脑开机显示下面几张图：CPU Fan Error请尝试检查CPU散热风扇的接线柱，是否正确安装到了CPU_FAN位置，CPU_OPT安装的应该是副风扇（一体水冷的时候基本是水泵） Please enter Setup to recover BIOS setting这个问题基本出现在上了年纪的电脑上，也就是是两年以上的电脑，原因就是主板电池没电了，造成了主板的设置不能正常保存，去附近的电脑店里面一个就OK了，5块钱吧。 故障二：无法上网网络标志显示红叉或者根本没有网络标志这种问题基本就是网卡没有启动导致的可能的原因就是驱动没装好 去下载主板网卡在当前系统版本下的驱动，系统版本有32位（X86）和64位（X64）之分，请看清楚 能用部分聊天软件，就是不能打开网页基本DNS的问题没的跑了,需要修改IP地址 修改本机当前ip配置。如何修改这个就要看系统版本了，不一样的版本入口不一样 对于win7可以点击小电脑图标-&gt;打开网络与共享设置-&gt;然后左侧边栏更改适配器设置-&gt;找到目前在用的链接(本地连接或者是无线网络)-&gt;右键属性-&gt;选择ipV4-&gt;属性-&gt;勾选手动设置 其他的例如win8 win8.1，win10 基本都一样，如果找不到那么就去搜索控制面板，然后进入网络与Internet 进入网络与共享中心 进入网络适配器页面 进入连接属性 进入ipv4协议属性 手动填写IP地址 这里面的东西如何填写需要根据你的路由器来决定的，基本上家里的设置都是192.168.1. ( 号填写100-254) 子网掩码 基本都是255.255.255.0 网关也是根据路由器来 192.168.1.1 DNS 第一行也可以根据路由器来：192.168.1.1 或者 指定固定的DNS，比如114.114.114.114 第二行随意 保存 如果上述方法不能解决建议重置网络服务 重置网络服务* 进入命令行工具（管理员模式）* 输入 netsh winsock reset 然后回车* 完成之后重启]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows--如何使用PE安装官方ISO镜像]]></title>
    <url>%2F2018%2F01%2F03%2FWindows--Use_PE_Installation_Windwos_ISO_Image%2F</url>
    <content type="text"><![CDATA[Windows–如何使用PE安装官方ISO镜像本文主要讲述如何使用普通U盘启动盘安装Windows重装系统,注意此方法只能安装于MBR分区表的硬盘 准备工作 制作U盘启动盘–普通PE类 下载官方ISO系统文件镜像（随便找一个不是C盘的目录放着就行，建议直接扔在D盘根目录） 然后新建一个文件夹叫 WindowsImage 解压这个ISO文件到 WindowsImage文件夹 首先 将制作好的U盘插入电脑的usb接口，然后开机 选择U盘启动 笔记本：自己去百度你的这个型号如何从U盘启动 台式机：去百度你这个电脑主板的U盘启动方法 进入PE 出现如下图所示的界面 选择带有运行**x86 或者 *x64 或者 windwos2003等字样的任何一个启动 进入PE 开始启动了 PE启动完成，现在可以操作了 安装windows系统 打开桌面上的windows安装器 点击install.wim文件的位置一项的选择 找到刚才解压的那个文件夹WindowsImage下的sources文件夹里面的install.wim文件（按大小排序按后最大的那个） 引导磁盘的位置—-选择C（最好自己去看看自己电脑现在在PE下的盘符，看一下你那个系统盘分区的盘符叫什么这里就选什么） 安装磁盘的位置—-选择C（最好自己去看看自己电脑现在在PE下的盘符，看一下你那个系统盘分区的盘符叫什么这里就选什么） 然后点击开始安装 如有对话框，则选择自动重新启动（对win10版本好像没用，需要手动重启）。不选保留原来的windows版本 确定 等待进度条完成 简书：http://www.jianshu.com/p/163b64432e97CSDN：http://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/78958115 完]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7.2配置LNMP环境记录]]></title>
    <url>%2F2017%2F12%2F31%2FCentOS7%E9%85%8D%E7%BD%AELNMP%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[CentOS7.2配置LNMP环境记录1php 7.0+ nginx 1.10+ mysql 5.5+ LNMP是Linux、Nginx、MySQL(MariaDB)和PHP的缩写，这个组合是最常见的WEB服务器的运行环境之一。本文将带领大家在CentOS 7操作系统上搭建一套LNMP环境。 本教程适用于CentOS 7.x版本。 准备工作更新 yum 源,自带的源没有 PHP7:1rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm 1rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 安装 epel:1yum install epel-release 升级系统1yum update 准备工作完成,开始安装! 安装NginxCentOS系统模板中配置了内网源，下载速度较快，推荐使用yum安装Nginx： 1sudo yum install nginx 按照提示，输入yes后开始安装。安装完毕后，Nginx的配置文件在/etc/nginx目录下。使用以下命令启动Nginx： 1sudo systemctl start nginx 检查系统中firewalld防火墙服务是否开启，如果已开启，我们需要修改防火墙配置，开启Nginx外网端口访问。 1sudo systemctl status firewalld 如果显示active (running)，则需要调整防火墙规则的配置。 修改/etc/firewalld/zones/public.xml文件，在zone一节中增加： 1234&lt;zone&gt; ... &lt;service name=&quot;nginx&quot;/&gt;&lt;zone&gt; 保存后重新加载firewalld服务： 1sudo systemctl restart firewalld 您可以通过浏览器访问 http://外网IP地址 来确定Nginx是否已经启动。 【注意：很重要！！！】部分童鞋发现按照教程操作最后无法访问，这是云服务器默认关闭了80端口。这个请移步云服务里控制台打开80端口的外网访问，如需步骤，请自行百度！ 最后将Nginx设置为开机启动： 1sudo systemctl enable nginx.service 这么Nginx就安装成功了！ 安装MySQL(MariaDB)MariaDB是MySQL的一个分支，主要由开源社区进行维护和升级，而MySQL被Oracle收购以后，发展较慢。在CentOS 7的软件仓库中，将MySQL更替为了MariaDB。 我们可以使用yum直接安装MariaDB： 1sudo yum install mariadb-server 安装完成之后，执行以下命令重启MariaDB服务： 1sudo systemctl restart mariadb MariaDB默认root密码为空，我们需要设置一下，执行脚本： 1sudo /usr/bin/mysql_secure_installation 这个脚本会经过一些列的交互问答来进行MariaDB的安全设置。 首先提示输入当前的root密码： Enter current password for root (enter for none):初始root密码为空，我们直接敲回车进行下一步。 Set root password? [Y/n]设置root密码，默认选项为Yes，我们直接回车，提示输入密码，在这里设置您的MariaDB的root账户密码。 Remove anonymous users? [Y/n] 是否移除匿名用户，默认选项为Yes，建议按默认设置，回车继续。 Disallow root login remotely? [Y/n]是否禁止root用户远程登录？如果您只在本机内访问MariaDB，建议按默认设置，回车继续。 如果您还有其他云主机需要使用root账号访问该数据库，则需要选择n。 Remove test database and access to it? [Y/n] 是否删除测试用的数据库和权限？建议按照默认设置，回车继续。 Reload privilege tables now? [Y/n]是否重新加载权限表？因为我们上面更新了root的密码，这里需要重新加载，回车。 完成后你会看到Success!的提示，MariaDB的安全设置已经完成。我们可以使用以下命令登录MariaDB： 1mysql -uroot -p 按提示输入root密码，就会进入MariaDB的交互界面，说明已经安装成功。 最后我们将MariaDB设置为开机启动。 1sudo systemctl enable mariadb php70w 安装PHP我们可以直接使用yum安装PHP： 123sudo yum install php70w-fpm php70w-mysql php70w-mysqli php70w php70w-opcache php70w-gd php70w-intl php70w-mbstring php70w-exif php70w-mcrypt php70w-openssl//把该安装的一次性装到位 安装完成后我们将php-fpm启动： 1sudo systemctl start php-fpm 将php-fpm设置为开机启动： 1sudo systemctl enable php-fpm 接下来需要注意了！配置Nginx–多个站点我给大家提供一个范本作为参考： 12nginx.conf//里面我会详细的给予中文注释 12vi /etc/nginx/nginx.conf//编辑nginx.conf的命令 以下为conf文件内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto;error_log /var/log/nginx/error.log; #错误日志记录的位置pid /run/nginx.pid; #nginx.pid为记录nginx主进程pid文件；切勿修改、移动# Load dynamic modules. See /usr/share/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;#引入/usr/share/nginx/modules/ 目录下的所有以.conf结尾的文件events &#123; worker_connections 1024;&#125;http &#123; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; #这句很重要，引入所有etc/nginx/conf.d/目录下的.conf文件 #***etc/nginx/conf.d/目录存放的就是分站点的文件（下面会给出实例代码）*** server &#123; #由于我们的nginx需要配置多站点，所以在此就需要注释一些东西 listen 80 default_server; listen [::]:80 default_server; #保留监听的端口 # server_name _; # root /usr/share/nginx/php; # Load configuration files for the default server block. # include /etc/nginx/default.d/*.conf; # location / &#123; # &#125; # error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; # location ~ \.php$ &#123; # root /usr/share/php; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; # include fastcgi_params; # &#125; &#125;# Settings for a TLS enabled server.## server &#123;# listen 443 ssl http2 default_server;# listen [::]:443 ssl http2 default_server;# server_name _;# root /usr/share/nginx/html;## ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;# ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;# ssl_session_cache shared:SSL:1m;# ssl_session_timeout 10m;# ssl_ciphers HIGH:!aNULL:!MD5;# ssl_prefer_server_ciphers on;## # Load configuration files for the default server block.# include /etc/nginx/default.d/*.conf;## location / &#123;# &#125;## error_page 404 /404.html;# location = /40x.html &#123;# &#125;## error_page 500 502 503 504 /50x.html;# location = /50x.html &#123;# &#125;# &#125;&#125;#注意：此份nginx.conf可以直接复制了去使用！~好用了就给博主打个赏钱！谢谢！ 配置完nginx之后我们该干啥、？当然是重启nginx呗 1sudo systemctl restart nginx #重启nginx 重启完毕，继续打开 http://外网IP地址 来确定Nginx是否已经启动。 此时，服务器启动的是nginx和apache。 而且php-fpm默认发送到apache。 所以咱们还得继续修改一下php-fpm。 配置 php-fpm123vi /etc/php-fpm.d/www.conf #编辑php-fpm配置文件 修改user和group （源代码为：user = apache group = apache） 12user = nginx group = nginx 修改完了之后，还是老样子，重启php-fpm服务 1systemctl restart php-fpm #重启php-fpm 最后，咱们需要为nginx添加站点了添加站点这我先给大家一个截图，以帮助大家迅速的了解是怎么回事 大家应该看的很清楚了，猜都可以猜到，博主这一共配置了三个站点，这三个站点是怎么被nginx引入的呢？ 1我给大家贴出nginx的配置文件的里面应该有这么一句(注意图中的红框，上面的是地址) 123include /etc/nginx/conf.d/*.conf;#这句很重要，引入所有etc/nginx/conf.d/目录下的.conf文件#***etc/nginx/conf.d/目录存放的就是分站点的文件（下面会给出实例代码）*** 好的，大家应该能准确理解了，如果还是理解不了的话只能缺你回去喝点三鹿了！ 下面我给大家贴出nginx站点配置文件的代码，修改修改就可以用看代码的时候请注意看里面的路径，当然我也还是会给一定的中文注释 123456789101112131415161718#这个文件是上面的qopmall.com.confserver &#123; server_name qopmall.com www.qopmall.com;#这里就是你要绑定的域名了，空格分开 location / &#123; root /usr/share/php/weixin; #这里是你站点存放的文件夹名称（也就是说，你当前这个站点的文件全部都丢在这个路径的weixin文件夹里面） index index.php index.html index.htm; #这里照抄即可 &#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \.php$ &#123; root /usr/share/php/weixin; #这里的配置等同于上面的那个root配置 fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /usr/share/php/weixin/$fastcgi_script_name; #这里的配置也是和上面的root配置一样 include fastcgi_params; &#125;&#125; 代码非常简单，我没注释到的不用修改就行。 上面的路径，比如/usr/share/php/weixin 这就是你站点的根目录，我给大家截图参考： 各位童鞋，创建好站点了，先写个简单的php程序测试一下是否正常，比如info。 完]]></content>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 如何加载本地html文件]]></title>
    <url>%2F2017%2F12%2F18%2FiOS%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%9C%AC%E5%9C%B0html%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[iOS 如何加载本地html文件???? 其实很简单 如下图所示 1234-(void)loadLocalHtml&#123; NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;/sfa/html/index.html&quot; withExtension:nil]; [self.webView loadRequest:[NSURLRequest requestWithURL:url]];&#125; 其中1@&quot;/sfa/html/index.html&quot; 部分是你的html文件相对于整个工程的路径例如下面这个工程构成图： 相关文件最好以文件方式导入而不是group CSDN: iOS 如何加载本地html文件 简书: iOS 如何加载本地html文件]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过assetURL获取到视频]]></title>
    <url>%2F2017%2F12%2F14%2FiOS--Use_ASSetURL_Get_Vedio%2F</url>
    <content type="text"><![CDATA[首先导入头文件 1#import &lt;Photos/Photos.h&gt; iOS中assetURL样式： 1assets-library://asset/asset.mov?id=F2E6E143-4343-4B57-87F9-346936E0EDB3&amp;ext=mov 使用当前的URL过滤到我们想要的数据 123456789101112131415161718192021222324252627282930PHFetchResult *result = [PHAsset fetchAssetsWithALAssetURLs:@[assetUrl] options:nil]; PHAsset * PHAsset = result.firstObject; /// 包含该视频的基础信息 PHAssetResource * resource = [[PHAssetResource assetResourcesForAsset: PHAsset] firstObject]; NSLog(@&quot;%@&quot;,resource); /* type: originalFilename: */ PHImageRequestOptions * options = [[PHImageRequestOptions alloc] init]; options.version = PHImageRequestOptionsVersionCurrent; options.deliveryMode = PHImageRequestOptionsDeliveryModeHighQualityFormat; options.synchronous = YES; __block NSData *videoData = nil; [[PHImageManager defaultManager] requestImageDataForAsset: PHAsset options: options resultHandler: ^(NSData * imageData, NSString * dataUTI, UIImageOrientation orientation, NSDictionary * info) &#123; NSLog(@&quot;%@&quot;,imageData); //这里的imageData就是视频数据; &#125;];]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS--如何计算出今天是周几]]></title>
    <url>%2F2017%2F08%2F23%2FiOS-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%87%BA%E4%BB%8A%E5%A4%A9%E6%98%AF%E5%91%A8%E5%87%A0%2F</url>
    <content type="text"><![CDATA[iOS–如何计算出今天是周几？？ 很简单： 123456789NSCalendar *cal = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierRepublicOfChina];NSInteger comp = [cal component:NSCalendarUnitWeekday fromDate:[NSDate date]];NSLog(@&quot;%ld&quot;,comp);NSDateComponents *comps = [cal components:NSCalendarUnitWeekday fromDate:[NSDate date]];NSLog(@&quot;%@&quot;,comps);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows电脑U盘启动盘制作]]></title>
    <url>%2F2017%2F08%2F19%2FWindows--Make_PE_Boot_USB_Disk%2F</url>
    <content type="text"><![CDATA[写在前面本文是博主鉴于当前任然后很大一部分电脑玩家经常为不会给爱机装系统而创作，本博主是一个精通电脑硬件性能以及软件使用的IT人士。 Windows的启动盘分为两类:(随便选择一种方法制作就OK了) 普通BIOS启动的PE类 UEFI启动的EFI类 无论是哪一类大家都不用担心，都有相对应的傻瓜式软件来帮我们完成，我们需要做的就是一下： 找一个U盘，最好是空的（因为无论是哪一种制作方式都可能会格式化这个U盘） U盘的大小最好是8GB左右的（第一种的方式大小无所谓，主要是第二种的方式会占用大量空间） 一台能联网的电脑（这个么有难度吧） 普通BIOS启动的PE类以下将简单介绍如何给Windows电脑制作一个普通BIOS启动的PE类U盘启动盘 准备工作下载U盘启动盘制作工具可以选的种类有很多个：老毛桃，U深度，大白菜，电脑店。。。。下面介绍的是电脑店。 下载地址：http://u.diannaodian.com/down 进入如图页面： 点击下载： 推荐点击本地下载： 然后就是等待下载完毕。。。。。。 在这个时候我们就可以开始对U盘做一些操作了(如果你的U盘不是空的话，如果里面没有东西，这一步可以跳过)，把U盘里面的所有东西都挪到电脑上（除了C盘的任何位置，只要你找的到就行）。 OK下载完了，开始安装：这个软件的安装很简单，就是单纯的吧这个下载的ZIP文件解压而已：我解压到了我的软件盘，盘符为D，如下图： 然后就是插上U盘，这时软件上面的U盘选择项就会出现你的U盘名称： 然后选择启动模式：（个人建议不要动保持USB-HDD模式） 然后选择U盘格式：（个人建议NTFS，因为Fat32有着文件大小的限制，单个文件的大小不得超过4GB） 都选择完了之后，那就点一下鼠标，点击全新制作：接下来就是等了。。。等。。。应该会很快完成之后：点击模拟启动，选择BIOS 至此，U盘启动盘已经制作完成。 UEFI启动的EFI类准备工作下载软碟通 百度就有： 安装： 接受协议，下一步。。。 注意改一下安装路径：（建议不要装在C盘，我的是在D盘） 一直下一步，知道结束 启动 选择继续试用： 选择上方工具栏的文件–打开：（选择你的系统镜像） 然后如图： 选择工具–写入磁盘镜像，插入U盘 点击写入：（没有合适的U盘 所以我这里是不能点的） 注意本类U盘启动盘只能以UEFI模式启动 请设置自己电脑的相关BIOS设置]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS自定义相机的实现]]></title>
    <url>%2F2017%2F08%2F18%2FiOS%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[iOS自定义相机的实现本文主要介绍iOS系统上的自定义相机的实现，其实并不难主要包含了，拍摄设备，输入端，输出端，以及抓取图像，保存图像的操作。 ###简单介绍组要控件 上方功能区 取消按钮 闪光灯按钮 相机切换按钮 下方功能区 拍照按钮 重新拍照按钮 选择照片按钮 图像展示视图 主要代码展示头文件内容展示 定了一个block，用于传输照片信息 123456#import &lt;UIKit/UIKit.h&gt;typedef void(^ImageBlock)(NSDictionary *imageDictionary);@interface CameraViewController : UIViewController@property (nonatomic, copy) ImageBlock imageblock;-(void)setImageblock:(void(^)(NSDictionary *imageDictionary))imageblock;@end 视图控件代码，逻辑代码展示 当前视图需要的主要空控件，为了方便操作全部定义为属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@interface CameraViewController ()&lt;AVCaptureMetadataOutputObjectsDelegate,UIAlertViewDelegate,CAAnimationDelegate&gt;//捕获设备，通常是前置摄像头，后置摄像头，麦克风（音频输入）@property(nonatomic)AVCaptureDevice *device;//AVCaptureDeviceInput 代表输入设备，他使用AVCaptureDevice 来初始化@property(nonatomic)AVCaptureDeviceInput *input;//当启动摄像头开始捕获输入@property(nonatomic)AVCaptureMetadataOutput *output;//输出@property (nonatomic)AVCaptureStillImageOutput *ImageOutPut;//session：由他把输入输出结合在一起，并开始启动捕获设备（摄像头）@property(nonatomic)AVCaptureSession *session;//图像预览层，实时显示捕获的图像@property(nonatomic)AVCaptureVideoPreviewLayer *previewLayer;//设备@property (nonatomic, strong)AVCaptureDevice *deveice;//拍照@property (nonatomic, strong) UIButton *PhotoButton;//闪光灯@property (nonatomic, strong) UIButton *flashButton;//取消@property (nonatomic, strong) UIButton *cancleButton;//切换摄像头@property (nonatomic, strong) UIButton *changeButton;//确定选择当前照片@property (nonatomic, strong) UIButton *selectButton;//重新拍照@property (nonatomic, strong) UIButton *reCamButton;//照片加载视图@property (nonatomic, strong) UIImageView *imageView;//对焦区域@property (nonatomic, strong) UIImageView *focusView;//上方功能区@property (nonatomic, strong) UIView *topView;//下方功能区@property (nonatomic, strong) UIView *bottomView;//闪光灯状态@property (nonatomic, assign) BOOL isflashOn;//拍到的照片@property (nonatomic, strong) UIImage *image;//照片的信息@property (nonatomic, strong) NSDictionary *imageDict;//是否可以拍照@property (nonatomic, assign) BOOL canCa;//闪光灯模式@property (nonatomic, assign) AVCaptureFlashMode flahMode;//前后摄像头@property (nonatomic, assign) AVCaptureDevicePosition cameraPosition;//模糊视图@property (nonatomic, strong) UIVisualEffectView *effectView;@end 使用懒加载，减少主要函数中的代码，看起来更为清爽。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164@implementation CameraViewController#pragma mark - 更改摄像头-(UIVisualEffectView *)effectView&#123; if (_effectView == nil) &#123; UIBlurEffect *effect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]; _effectView = [[UIVisualEffectView alloc] initWithEffect:effect]; _effectView.frame = CGRectMake(0, 0, ScreenWidth(), ScreenHieght()); _effectView.alpha = 1; &#125; return _effectView;&#125; #pragma mark - 更改闪光灯状态-(void)setIsflashOn:(BOOL)isflashOn&#123; _isflashOn = isflashOn; [[NSUserDefaults standardUserDefaults] setObject:@(_isflashOn) forKey:@&quot;flashMode&quot;]; if (_isflashOn) &#123; [self.flashButton setBackgroundImage:[UIImage imageNamed:@&quot;flash_on&quot;] forState:UIControlStateNormal]; &#125;else&#123; [self.flashButton setBackgroundImage:[UIImage imageNamed:@&quot;flash_off&quot;] forState:UIControlStateNormal]; &#125;&#125;#pragma mark - 上方功能区-(UIView *)topView&#123; if (!_topView ) &#123; _topView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, ScreenWidth(), 50)]; _topView.backgroundColor = [UIColor colorWithRed:1 green:1 blue:1 alpha:0.2]; [_topView addSubview:self.cancleButton]; [_topView addSubview:self.flashButton]; [_topView addSubview:self.changeButton]; &#125; return _topView;&#125;#pragma mark - 取消-(UIButton *)cancleButton&#123; if (_cancleButton == nil) &#123; _cancleButton = [UIButton buttonWithType:UIButtonTypeCustom]; _cancleButton.frame = CGRectMake(20, 10, 60, 30); [_cancleButton setTitle:@&quot;取消&quot; forState:UIControlStateNormal]; [_cancleButton addTarget:self action:@selector(cancle) forControlEvents:UIControlEventTouchUpInside]; &#125; return _cancleButton ;&#125;#pragma mark - 闪光灯-(UIButton *)flashButton&#123; if (_flashButton == nil) &#123; _flashButton = [UIButton buttonWithType:UIButtonTypeCustom]; _flashButton.frame = CGRectMake((ScreenWidth()-30)/2.0, 10, 30, 30); [_flashButton addTarget:self action:@selector(FlashOn) forControlEvents:UIControlEventTouchUpInside]; &#125; return _flashButton;&#125;#pragma mark - 切换摄像头-(UIButton *)changeButton&#123; if (_changeButton == nil) &#123; _changeButton = [UIButton buttonWithType:UIButtonTypeCustom]; _changeButton.frame = CGRectMake(ScreenWidth()-40, 10, 30, 30); [_changeButton setBackgroundImage:[UIImage imageNamed:@&quot;cam&quot;] forState:UIControlStateNormal]; [_changeButton addTarget:self action:@selector(changeCamera) forControlEvents:UIControlEventTouchUpInside]; &#125; return _changeButton;&#125;#pragma mark - 下方功能区-(UIView *)bottomView&#123; if (!_bottomView) &#123; _bottomView = [[UIView alloc] initWithFrame:CGRectMake(0, ScreenHieght()-80, ScreenWidth(), 80)]; _bottomView.backgroundColor = [UIColor colorWithRed:1 green:1 blue:1 alpha:0.4]; [_bottomView addSubview:self.reCamButton]; [_bottomView addSubview:self.PhotoButton]; [_bottomView addSubview:self.selectButton]; &#125; return _bottomView;&#125;-(UIButton *)reCamButton&#123; if (_reCamButton == nil) &#123; _reCamButton = [UIButton buttonWithType:UIButtonTypeCustom]; _reCamButton.frame = CGRectMake(40, 25, 80, 30); [_reCamButton addTarget:self action:@selector(reCam) forControlEvents:UIControlEventTouchUpInside]; [_reCamButton setTitle:@&quot;重新拍照&quot; forState:UIControlStateNormal]; [_reCamButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal]; _reCamButton.alpha = 0; &#125; return _reCamButton;&#125;-(UIButton *)PhotoButton&#123; if (_PhotoButton == nil) &#123; _PhotoButton = [UIButton buttonWithType:UIButtonTypeCustom]; _PhotoButton.frame = CGRectMake(ScreenWidth()/2.0-30, 10, 60, 60); [_PhotoButton setImage:[UIImage imageNamed:@&quot;photograph&quot;] forState: UIControlStateNormal]; [_PhotoButton setImage:[UIImage imageNamed:@&quot;photograph_Select&quot;] forState:UIControlStateNormal]; [_PhotoButton addTarget:self action:@selector(shutterCamera) forControlEvents:UIControlEventTouchUpInside]; &#125; return _PhotoButton;&#125;-(UIButton *)selectButton&#123; if (_selectButton == nil) &#123; _selectButton = [UIButton buttonWithType:UIButtonTypeCustom]; _selectButton.frame = CGRectMake(ScreenWidth()-120, 25, 80, 30); [_selectButton addTarget:self action:@selector(selectImage) forControlEvents:UIControlEventTouchUpInside]; [_selectButton setTitle:@&quot;选择照片&quot; forState:UIControlStateNormal]; [_selectButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal]; _selectButton.alpha = 0; &#125; return _selectButton;&#125;#pragma mark - 加载照片的视图-(UIImageView *)imageView&#123; if (_imageView == nil) &#123; _imageView = [[UIImageView alloc]initWithFrame:self.previewLayer.frame]; _imageView.layer.masksToBounds = YES; _imageView.image = _image; &#125; return _imageView;&#125;#pragma mark - 对焦区域-(UIImageView *)focusView&#123; if (_focusView == nil) &#123; _focusView = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 80, 80)]; _focusView.backgroundColor = [UIColor clearColor]; _focusView.image = [UIImage imageNamed:@&quot;foucs80pt&quot;]; &#125; return _focusView;&#125;#pragma mark - 使用self.session，初始化预览层，self.session负责驱动input进行信息的采集，layer负责把图像渲染显示-(AVCaptureVideoPreviewLayer *)previewLayer&#123; if (_previewLayer == nil) &#123; _previewLayer = [[AVCaptureVideoPreviewLayer alloc]initWithSession:self.session]; _previewLayer.frame = CGRectMake(0, 0, ScreenWidth(), ScreenHieght()); _previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill; &#125; return _previewLayer;&#125;-(AVCaptureStillImageOutput *)ImageOutPut&#123; if (_ImageOutPut == nil) &#123; _ImageOutPut = [[AVCaptureStillImageOutput alloc] init]; &#125; return _ImageOutPut;&#125;#pragma mark - 初始化输入-(AVCaptureDeviceInput *)input&#123; if (_input == nil) &#123; _input = [[AVCaptureDeviceInput alloc]initWithDevice:self.device error:nil]; &#125; return _input;&#125;#pragma mark - 初始化输出-(AVCaptureMetadataOutput *)output&#123; if (_output == nil) &#123; _output = [[AVCaptureMetadataOutput alloc]init]; &#125; return _output;&#125;#pragma mark - 使用AVMediaTypeVideo 指明self.device代表视频，默认使用后置摄像头进行初始化-(AVCaptureDevice *)device&#123; if (_device == nil) &#123; _device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; &#125; return _device;&#125; 主要逻辑代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#pragma mark - 当前视图控制器的初始化- (instancetype)init&#123; self = [super init]; if (self) &#123; _canCa = [self canUserCamear]; &#125; return self;&#125;-(void)setImageblock:(void (^)(NSDictionary *))imageblock&#123; _imageblock = imageblock;&#125;#pragma mark - 检查相机权限- (BOOL)canUserCamear&#123; AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]; if (authStatus == AVAuthorizationStatusDenied) &#123; UIAlertView *alertView = [[UIAlertView alloc]initWithTitle:@&quot;请打开相机权限&quot; message:@&quot;设置-隐私-相机&quot; delegate:self cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:@&quot;取消&quot;, nil]; alertView.tag = 100; [alertView show]; return NO; &#125; else&#123; return YES; &#125; return YES;&#125;#pragma mark - 视图加载- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor clearColor]; if (_canCa) &#123; [self customCamera]; [self customUI]; [self FlashOn]; &#125;else&#123; return; &#125; // Do any additional setup after loading the view, typically from a nib.&#125;#pragma mark - 自定义视图- (void)customUI&#123; [self.view addSubview:self.topView]; [self.view addSubview:self.bottomView]; [self.view addSubview:self.focusView]; UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(focusGesture:)]; [self.view addGestureRecognizer:tapGesture]; &#125;#pragma mark - 自定义相机- (void)customCamera&#123; //生成会话，用来结合输入输出 self.session = [[AVCaptureSession alloc]init]; if ([self.session canSetSessionPreset:AVCaptureSessionPresetPhoto]) &#123; self.session.sessionPreset = AVCaptureSessionPresetPhoto; &#125; if ([self.session canAddInput:self.input]) &#123; [self.session addInput:self.input]; &#125; if ([self.session canAddOutput:self.ImageOutPut]) &#123; [self.session addOutput:self.ImageOutPut]; &#125; [self.view.layer addSublayer:self.previewLayer]; //开始启动 [self.session startRunning]; if ([self.device lockForConfiguration:nil]) &#123; if ([self.device isFlashModeSupported:AVCaptureFlashModeAuto]) &#123; [self.device setFlashMode:AVCaptureFlashModeAuto]; &#125; //自动白平衡 if ([self.device isWhiteBalanceModeSupported:AVCaptureWhiteBalanceModeAutoWhiteBalance]) &#123; [self.device setWhiteBalanceMode:AVCaptureWhiteBalanceModeAutoWhiteBalance]; &#125; [self.device unlockForConfiguration]; &#125; [self focusAtPoint:self.view.center];&#125; *闪光灯 1234567891011121314151617181920#pragma 闪光灯- (void)FlashOn&#123; if ([self.device lockForConfiguration:nil]) &#123; if (self.isflashOn) &#123; if ([self.device isFlashModeSupported:AVCaptureFlashModeOff]) &#123; [self.device setFlashMode:AVCaptureFlashModeOff]; self.isflashOn = NO; //[self.flashButton setTitle:@&quot;关&quot; forState:UIControlStateNormal]; &#125; &#125;else&#123; if ([self.device isFlashModeSupported:AVCaptureFlashModeAuto]) &#123; [self.device setFlashMode:AVCaptureFlashModeAuto]; self.isflashOn = YES; //[self.flashButton setTitle:@&quot;开&quot; forState:UIControlStateNormal]; &#125; &#125; [self.device unlockForConfiguration]; &#125;&#125; 双摄像头切换，切换时使用高斯模糊对试图进行处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#pragma mark - 相机切换- (void)changeCamera&#123; NSUInteger cameraCount = [[AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo] count]; if (cameraCount &gt; 1) &#123; self.changeButton.userInteractionEnabled = NO; [self cutoff]; NSError *error; CATransition *animation = [CATransition animation]; animation.duration = 1; animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; animation.type = @&quot;oglFlip&quot;; animation.delegate = self; AVCaptureDevice *newCamera = nil; AVCaptureDeviceInput *newInput = nil; AVCaptureDevicePosition position = [[self.input device] position]; if (position == AVCaptureDevicePositionFront)&#123; newCamera = [self cameraWithPosition:AVCaptureDevicePositionBack]; animation.subtype = kCATransitionFromLeft; self.cameraPosition = AVCaptureDevicePositionBack; &#125;else &#123; newCamera = [self cameraWithPosition:AVCaptureDevicePositionFront]; animation.subtype = kCATransitionFromRight; self.cameraPosition = AVCaptureDevicePositionFront; &#125; newInput = [AVCaptureDeviceInput deviceInputWithDevice:newCamera error:nil]; [self.previewLayer addAnimation:animation forKey:nil]; /* 高斯模糊 */ [self.imageView addSubview:self.effectView]; [self.view insertSubview:self.imageView belowSubview:self.topView]; // if (newInput != nil) &#123; [self.session beginConfiguration]; [self.session removeInput:self.input]; if ([self.session canAddInput:newInput]) &#123; [self.session addInput:newInput]; self.input = newInput; &#125; else &#123; [self.session addInput:self.input]; &#125; [self.session commitConfiguration]; &#125; else if (error) &#123; NSLog(@&quot;toggle carema failed, error = %@&quot;, error); &#125; //[self.session startRunning]; &#125;&#125;- (AVCaptureDevice *)cameraWithPosition:(AVCaptureDevicePosition)position&#123; NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; for ( AVCaptureDevice *device in devices ) if ( device.position == position ) return device; return nil;&#125;-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123; self.changeButton.userInteractionEnabled = YES; [self.effectView removeFromSuperview]; [self.imageView removeFromSuperview]; if (self.cameraPosition == AVCaptureDevicePositionFront) &#123; self.flashButton.alpha = 0; &#125;else if (self.cameraPosition == AVCaptureDevicePositionBack)&#123; self.flashButton.alpha = 1; &#125; [self.session startRunning];&#125; 摄像头对焦 1234567891011121314151617181920212223242526272829303132333435363738#pragma mark - 聚焦- (void)focusGesture:(UITapGestureRecognizer*)gesture&#123; CGPoint point = [gesture locationInView:gesture.view]; [self focusAtPoint:point];&#125;- (void)focusAtPoint:(CGPoint)point&#123; CGSize size = self.view.bounds.size; CGPoint focusPoint = CGPointMake( point.y /size.height ,1-point.x/size.width ); NSError *error; if ([self.device lockForConfiguration:&amp;error]) &#123; if ([self.device isFocusModeSupported:AVCaptureFocusModeAutoFocus]) &#123; [self.device setFocusPointOfInterest:focusPoint]; [self.device setFocusMode:AVCaptureFocusModeAutoFocus]; &#125; if ([self.device isExposureModeSupported:AVCaptureExposureModeAutoExpose ]) &#123; [self.device setExposurePointOfInterest:focusPoint]; [self.device setExposureMode:AVCaptureExposureModeAutoExpose]; &#125; [self.device unlockForConfiguration]; self.focusView.center = point; //[self startFocusAnimation]; self.focusView.alpha = 1; [UIView animateWithDuration:0.2 animations:^&#123; self.focusView.transform = CGAffineTransformMakeScale(1.25f, 1.25f); &#125; completion:^(BOOL finished) &#123; [UIView animateWithDuration:0.3 animations:^&#123; self.focusView.transform = CGAffineTransformMakeScale(1.0f, 1.0f); &#125; completion:^(BOOL finished) &#123; [self hiddenFocusAnimation]; &#125;]; &#125;]; &#125; &#125; 主要功能按钮 拍照按钮123456789101112131415161718192021222324252627#pragma mark - 拍照- (void)shutterCamera&#123; AVCaptureConnection * videoConnection = [self.ImageOutPut connectionWithMediaType:AVMediaTypeVideo]; if (!videoConnection) &#123; NSLog(@&quot;take photo failed!&quot;); return; &#125; [self.ImageOutPut captureStillImageAsynchronouslyFromConnection:videoConnection completionHandler:^(CMSampleBufferRef imageDataSampleBuffer, NSError *error) &#123; if (imageDataSampleBuffer == NULL) &#123; return; &#125; NSData * imageData = [AVCaptureStillImageOutput jpegStillImageNSDataRepresentation:imageDataSampleBuffer]; self.image = [UIImage imageWithData:imageData]; self.imageDict = @&#123;@&quot;image&quot;:self.image,@&quot;info&quot;:@&#123;@&quot;PHImageFileUTIKey&quot;:@&quot;.jpeg&quot;&#125;&#125;; [self.session stopRunning]; //[self.view insertSubview:self.imageView belowSubview:self.PhotoButton]; [self.view insertSubview:self.imageView aboveSubview:self.topView]; NSLog(@&quot;image size = %@&quot;,NSStringFromCGSize(self.image.size)); self.topView.alpha = 0; self.PhotoButton.alpha = 0; self.reCamButton.alpha = 1; self.selectButton.alpha = 1; &#125;];&#125; 保存至相册 12345678910111213141516171819#pragma - 保存至相册- (void)saveImageToPhotoAlbum:(UIImage*)savedImage&#123; UIImageWriteToSavedPhotosAlbum(savedImage, self, @selector(image:didFinishSavingWithError:contextInfo:), NULL); &#125;// 指定回调方法- (void)image: (UIImage *) image didFinishSavingWithError: (NSError *) error contextInfo: (void *) contextInfo&#123; if(error != NULL)&#123; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;保存图片结果提示&quot; message:@&quot;保存图片失败&quot; delegate:self cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil]; [alert show]; &#125;&#125; 取消 返回上级 12345678910111213141516171819#pragma mark - 取消 返回上级-(void)cancle&#123; [self.imageView removeFromSuperview]; [self.session stopRunning]; [self.navigationController popViewControllerAnimated:YES];&#125;- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; if (buttonIndex == 0 &amp;&amp; alertView.tag == 100) &#123; NSURL * url = [NSURL URLWithString:UIApplicationOpenSettingsURLString]; if([[UIApplication sharedApplication] canOpenURL:url]) &#123; [[UIApplication sharedApplication] openURL:url]; &#125; &#125;&#125; 重新拍照 12345678910#pragma mark - 重新拍照- (void)reCam&#123; self.imageView.image = nil; [self.imageView removeFromSuperview]; [self.session startRunning]; self.topView.alpha = 1; self.PhotoButton.alpha = 1; self.reCamButton.alpha = 0; self.selectButton.alpha = 0;&#125; 选择照片 返回上级 123456789101112131415#pragma mark - 选择照片 返回上级- (void)selectImage&#123; [self saveImageToPhotoAlbum:self.image]; self.imageblock(self.image); [self.navigationController popViewControllerAnimated:YES];&#125;-(void)viewDidDisappear:(BOOL)animated&#123; &#125;- (void)focusDidFinsh&#123; self.focusView.hidden = YES; self.focusView.transform = CGAffineTransformMakeScale(1.0f, 1.0f); //self.focusView.transform=CGAffineTransformMakeScale(0.7f, 0.7f);&#125; 对焦框动画1234567891011121314151617181920212223242526- (void)startFocusAnimation&#123; self.focusView.hidden = NO; self.focusView.transform = CGAffineTransformMakeScale(1.25f, 1.25f);//将要显示的view按照正常比例显示出来 [UIView beginAnimations:nil context:UIGraphicsGetCurrentContext()]; //[UIView setAnimationCurve:UIViewAnimationCurveEaseInOut]; //InOut 表示进入和出去时都启动动画 //[UIView setAnimationWillStartSelector:@selector(hiddenFoucsView)]; [UIView setAnimationDidStopSelector:@selector(hiddenFocusAnimation)]; [UIView setAnimationDuration:0.5f];//动画时间 self.focusView.transform = CGAffineTransformIdentity;//先让要显示的view最小直至消失 [UIView commitAnimations]; //启动动画 //相反如果想要从小到大的显示效果，则将比例调换 &#125;- (void)hiddenFocusAnimation&#123; [UIView beginAnimations:nil context:UIGraphicsGetCurrentContext()]; //NSDate *DATE = [NSDate date]; //[UIView setAnimationStartDate:[NSDate date]]; [UIView setAnimationDelay:3]; self.focusView.alpha = 0; [UIView setAnimationDuration:0.5f];//动画时间 [UIView commitAnimations]; &#125;- (void)hiddenFoucsView&#123; self.focusView.alpha = !self.focusView.alpha;&#125; 写在最后 第一次自定义一个相机，代码写的可能不太好理解。 这个项目在码云的git库上有，地址为https://git.oschina.net/LiynXu/PhotoDemo.git。 如果有任何意见或者建议，或者发现bug(应该是有的),请移步值git库下给予指导，3Q。]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐讯K2刷华硕固件]]></title>
    <url>%2F2017%2F08%2F18%2F%E6%96%90%E8%AE%AFK2%E5%88%B7%E5%8D%8E%E7%A1%95%E5%9B%BA%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[写在前面斐讯K2是一款处于1200Mbps(300+867Mbps)无线速率段的双频802.11ac路由器，2.4G+5G双频并发，PA+LNA强强组合，智能管理轻松控制，斐讯K2完美诠释了“家再大，隔墙再多，WiFi信号不受阻隔”的上网体验。斐讯K2路由器可以在京东免费撸，很多朋友撸回家发现固件太垃圾，各种不好用，因此想把斐讯K2刷成华硕固件。 中关村斐讯K2 重要说明 据说，这种方法支持斐讯K2的固件版本为： 22.3.15.128 22.3.15.232 22.3.17.148 22.4.2.8 22.4.2.9 如果目前你的斐讯K2路由器的固件版本高于或者低于这几个版本，可以进行升级或者降级操作，然后按照。下面我会提供相关文件的下载地址，方便大家下载后进行升级和降级操作。点击 百度网盘或者复制链接: https://pan.baidu.com/s/1gfssXUz 密码: qdke 第一步：——自带固件降级—–降级分为两个版本，一个是老版本22.5.9，另外一个是22.5.11，因为在.11版本降级会出现提示，非法固件而不允许刷机，那么我们就是用另外一种方法来进行刷机 首先22.5.9版本降级第1步a、进入系统设置，找到手动升级，选择k2_163_v11_breed.bin ，然后升级 第2步a、升级完成后，断开路由器电源。 b、按住复位键，插上电源，等待7秒钟后松开复位键。 第3步 a、进入breed web设置页面 22.5.11版本降级第1步1、安装Firefox浏览器。 2、用网线连接电脑和路由器的Lan口（WAN口无所谓，联不联网无所谓），K1、K2默认登录密码修改为admin。 第2步、开启telnet工作1、打开Firefox浏览器登陆斐讯路由器，选择右上角的“定时重启路由器”，如图。 2、点击指定重启时间，将鼠标箭头放到05上，右键选择“查看元素”。注意一定要放在05上； 3、在查看器中将鼠标移到”05”上（找不到05的话刷新一下网页），点击鼠标右键，选择“编程HTML”。 4、将”05”改成”01:00 | telnetd -l /bin/login.sh”（复制粘贴即可），然后鼠标移动到黑框之外的空白处点击鼠标左键，就可以完成编辑了。 5、在定时重启路由器页面上选择05之后（注意现在回变成1：00…..），点击“保存”。 那么现在就完成了开启K2路由器telnet服务的工作。6、下载目录内breed Web助手（3.4版本）–&gt;关闭防火墙，退出杀毒软件–&gt;找到这个文件“路由器刷breed Web助手通用版v3.0”–&gt;右键以管理员身份运行 7、如图刷机方案选择：”通用方案[需要开启路由器telnet或ssh]”，然后点击开始刷机； 8、完成后这样就完成了斐讯路由器刷入不死Breed。 第二步： a、进入breed界面 b、在菜单固件更新中，选择文件哪一行，选择SW_K2_703004657_V22.4.2.8.bin 固件 c、等待上传完成 e、请等待升级完成，自动重启后。然后按住复位键7秒，等待重启后。 到此你的路由器固件成功降级到了22.4.2.8 f、注意右下角的固件版本号 ——刷入华硕固件—–第1步–刷入breed和ssh a、点击“高级设置”——&gt;“备份恢复”——&gt;“浏览”找到刚才下载的：tianbaoha_breed_ssh.dat文件——&gt;“恢复备份”。 b、路由器会自动重启，等待重启完成 c、验证 斐讯K2重启完成后，重新在浏览器中输入p.to或者192.168.2.1，打开登录界面，管理密码用：tianbaoha 。如果可以登录到设置界面，说明breed和ssh已经刷入成功。 第2步a、管理密码用：tianbaoha 登录到K2的设置界面后，点击“高级设置”——&gt;“系统设置”——&gt;“手动升级”——&gt;点击 下载备份EEPROM，如下图所示。 第3步–刷写华硕固件登录地址：192.168.123.1 管理账号：admin/admin 默认wifi密码：1234567890 a、点击“高级设置”——&gt;“系统设置”——&gt;“手动升级”——&gt;点击“浏览”，找到刚才下载的华硕固件:RT-AC54U-GPIO-1-PSG1208-64M_3.4.3.9-099.trx b、点击“升级”。 第4步 a、等待路由器重启。 b、在浏览器中输入：192.168.123.1 打开登录界面——&gt;用户名和密码用：admin/admin，登录到界面了 结束]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS HealthKit简单介绍]]></title>
    <url>%2F2017%2F08%2F18%2FiOS--HealthKit%2F</url>
    <content type="text"><![CDATA[HealthKit简单介绍目前很多App都会有访问健康数据的需求，那么我们就不得不使用HealthKit。HealthKit框架提供了一个结构，应用可以使用它来分享健康和健身数据。HealthKit管理从不同来源获得的数据，并根据用户的偏好设置，自动将不同来源的所有数据合并起来。应用还可以获取每个来源的原始数据，然后执行自己的数据合并。 如何在项目中集成HealthKit这一个部分我们将一步一步的在项目中集成HealthKit。 第一步添加HealthKit1、进入项目设置–&gt;Capabilities–&gt;HealthKit，然后如下图打开就可以了，如果下面几个选项前都打上了勾的话，那么就代表OK了，一般也不会出现X。 2、如果上面的步骤完成了的话那么在工程目录下会多一个文件，这个文件以工程名命名，后缀名为entitlements，如下图： 3、并且在Frameworks目录下会多一个HealthKit.framework文件： 项目中的使用首先要在需要访问健康数据的地方，使用import导入HealthKit头文件： 1#import &lt;HealthKit/HealthKit.h&gt; 然后写一个属性： 1@property (nonatomic, strong) HKHealthStore *healthStore; 1、这一步为你的应用实例化一个 HKHealthStore 对象。每个应用只需要一个HealthKit存储实例。这个存储实例就是你和HealthKit数据库交互的主要接口。 1self.healthStore = [[HKHealthStore alloc] init]; 2、 调用 isHealthDataAvailable 方法来查看HealthKit在该设备上是否可用。HealthKit在iPad上不可用。 123if ([HKHealthStore isHealthDataAvailable]) &#123; NSLog(@&quot;HealthDataAvailable&quot;); &#125; 3、在项目中具体代码： 1234567891011121314151617181920212223//创建想要获取的数据类型 HKObjectType *stepCpunt = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierStepCount];//步数 HKObjectType *Height = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierHeight];//身高 HKObjectType *BodyMass = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierBodyMass];//体重 HKObjectType *DistanceWalkingRunning = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierDistanceWalkingRunning];//步行+跑步距离 HKObjectType *DistanceCycling = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierDistanceCycling];//骑行距离 //一个集合，数据类型 NSSet *healthSet = [NSSet setWithObjects:stepCpunt,Height,BodyMass,DistanceWalkingRunning,DistanceCycling,nil]; //[self.healthStore requestAuthorizationToShareTypes:nil readTypes:healthSet completion:nil]; //向系统的健康APP请求数据，并回调结果 [self.healthStore requestAuthorizationToShareTypes:nil readTypes:healthSet completion:^(BOOL success, NSError * _Nullable error) &#123; if (success) &#123; NSLog(@&quot;requestAuthorization success&quot;); [self readHealthData:HKQuantityTypeIdentifierStepCount]; [self readHealthData:HKQuantityTypeIdentifierDistanceWalkingRunning]; [self readHealthData:HKQuantityTypeIdentifierDistanceCycling]; [self readHealthData:HKQuantityTypeIdentifierHeight]; [self readHealthData:HKQuantityTypeIdentifierBodyMass]; &#125;else&#123; NSLog(@&quot;requestAuthorization error&quot;); &#125; &#125;]; 具体的数据获的操作 123456789101112131415161718192021222324252627282930313233//查询数据- (void)readHealthData:(NSString* )HKQuantityTypeIdentifierType&#123; //查询采样信息 HKSampleType *sampleType = [HKQuantityType quantityTypeForIdentifier:HKQuantityTypeIdentifierType]; //NSSortDescriptors用来告诉healthStore怎么样将结果排序。 NSSortDescriptor *start = [NSSortDescriptor sortDescriptorWithKey:HKSampleSortIdentifierStartDate ascending:NO]; NSSortDescriptor *end = [NSSortDescriptor sortDescriptorWithKey:HKSampleSortIdentifierEndDate ascending:NO]; /* 查询的基类是HKQuery，这是一个抽象类，能够实现每一种查询目标，这里我们需要查询的步数是一个 HKSample类所以对应的查询类就是HKSampleQuery。 下面的limit参数传1表示查询最近一条数据,查询多条数据只要设置limit的参数值就可以了 在这里我们需要定义block里面执行哪些语句 */ HKSampleQuery *sampleQuery = [[HKSampleQuery alloc] initWithSampleType:sampleType predicate:nil limit:2 sortDescriptors:@[start,end] resultsHandler:^(HKSampleQuery * _Nonnull query, NSArray&lt;__kindof HKSample *&gt; * _Nullable results, NSError * _Nullable error) &#123; //打印查询结果 NSLog(@&quot;resultCount = %ld result = %@&quot;,results.count,results); //把结果装换成字符串类型 if (results.count!=0) &#123; HKQuantitySample *result = results[0]; HKQuantity *quantity = result.quantity; NSString *stepStr = (NSString *)quantity; [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; //查询是在多线程中进行的，如果要对UI进行刷新，要回到主线程中 NSLog(@&quot;最新数据：%@&quot;,stepStr); &#125;]; &#125;else&#123; NSLog(@&quot;没有健康数据&quot;); &#125; &#125;]; //执行查询 [self.healthStore executeQuery:sampleQuery];&#125; 运行结果在这里]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS日志本地化--日志重定向]]></title>
    <url>%2F2017%2F08%2F18%2FiOS%E6%97%A5%E5%BF%97%E6%9C%AC%E5%9C%B0%E5%8C%96--%E6%97%A5%E5%BF%97%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[写在前面本文主要是给读者分享技术的，如何保存能控制台输出的log，以便于查找程序本身出现的问题。 我们该如何做 首先我们要判断，是不是模拟器 1234567#if !(TARGET_IPHONE_SIMULATOR)//真机 //连接xcode时可以从监视器中看日志 没连接时Log日志会输出到文件中， [self redirectNSLogToDocumentFolder]; NSLog(@&quot;真机&quot;);#else//模拟器 NSLog(@&quot;模拟器&quot;);#endif 其次我们还要接着判断是不是真机连接了Xcode，然后才开始进行日志本地化文件的生成 12345678910111213141516171819202122232425262728293031323334- (void)redirectNSLogToDocumentFolder&#123; //如果已经连接Xcode调试则不输出到文件 if(isatty(STDOUT_FILENO)) &#123; return; &#125; UIDevice *device = [UIDevice currentDevice]; if([[device model] hasSuffix:@&quot;Simulator&quot;])&#123; //在模拟器不保存到文件中 return; &#125; //将NSlog打印信息保存到Document目录下的Log文件夹下 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *logDirectory = [[paths objectAtIndex:0] stringByAppendingPathComponent:@&quot;Log&quot;]; NSFileManager *fileManager = [NSFileManager defaultManager]; BOOL fileExists = [fileManager fileExistsAtPath:logDirectory]; if (!fileExists) &#123; [fileManager createDirectoryAtPath:logDirectory withIntermediateDirectories:YES attributes:nil error:nil]; &#125; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;]]; [formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;]; //每次启动后都保存一个新的日志文件中 NSString *dateStr = [formatter stringFromDate:[NSDate date]]; self.filepath = [logDirectory stringByAppendingFormat:@&quot;/%@.log&quot;,dateStr]; // 将log输入到文件 freopen([self.filepath cStringUsingEncoding:NSASCIIStringEncoding], &quot;a+&quot;, stdout); freopen([self.filepath cStringUsingEncoding:NSASCIIStringEncoding], &quot;a+&quot;, stderr); //未捕获的Objective-C异常日志 NSSetUncaughtExceptionHandler (&amp;UncaughtExceptionHandler);&#125; 最后这是一个报错的异常信息，也就是我们所说的崩溃信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344void UncaughtExceptionHandler(NSException* exception)&#123; NSString* name = [ exception name ]; NSString* reason = [ exception reason ]; NSArray* symbols = [ exception callStackSymbols ]; // 异常发生时的调用栈 NSMutableString* strSymbols = [ [ NSMutableString alloc ] init ]; //将调用栈拼成输出日志的字符串 for ( NSString* item in symbols ) &#123; [ strSymbols appendString: item ]; [ strSymbols appendString: @&quot;\r\n&quot; ]; &#125; //将crash日志保存到Document目录下的Log文件夹下 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *logDirectory = [[paths objectAtIndex:0] stringByAppendingPathComponent:@&quot;Log&quot;]; NSFileManager *fileManager = [NSFileManager defaultManager]; if (![fileManager fileExistsAtPath:logDirectory]) &#123; [fileManager createDirectoryAtPath:logDirectory withIntermediateDirectories:YES attributes:nil error:nil]; &#125; //NSString *logFilePath = [logDirectory stringByAppendingPathComponent:@&quot;UncaughtException.log&quot;]; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;]]; [formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;]; AppDelegate *app = [UIApplication sharedApplication].delegate; NSString *dateStr = [formatter stringFromDate:app.date]; NSString *crashString = [NSString stringWithFormat:@&quot;&lt;- %@ -&gt;[ Uncaught Exception ]\r\nName: %@, Reason: %@\r\n[ Fe Symbols Start ]\r\n%@[ Fe Symbols End ]\r\n\r\n&quot;, dateStr, name, reason, strSymbols]; //把错误日志写到文件中 if (![fileManager fileExistsAtPath:app.filepath]) &#123; [crashString writeToFile:app.filepath atomically:YES encoding:NSUTF8StringEncoding error:nil]; &#125;else&#123; NSFileHandle *outFile = [NSFileHandle fileHandleForWritingAtPath:app.filepath]; [outFile seekToEndOfFile]; [outFile writeData:[crashString dataUsingEncoding:NSUTF8StringEncoding]]; [outFile closeFile]; &#125; //把错误日志发送到邮箱 NSString *urlStr = [NSString stringWithFormat:@&quot;mailto://邮箱账号?subject=bug报告&amp;body=感谢您的配合!错误详情:%@&quot;,crashString ]; NSURL *url = [NSURL URLWithString:[urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]]; [[UIApplication sharedApplication] openURL:url];&#125; 使用在AppDelegate的这个方法中编写如下代码 12345678910- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;#if !(TARGET_IPHONE_SIMULATOR)//真机 //连接xcode时可以从监视器中看日志 没连接时Log日志会输出到文件中， [self redirectNSLogToDocumentFolder]; NSLog(@&quot;真机&quot;);#else//模拟器 NSLog(@&quot;模拟器&quot;);#endifreturn YES;&#125;]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS实例化对象转换为JSON数据]]></title>
    <url>%2F2017%2F08%2F18%2FiOS--Custom_Object_To_JSON_Runtime%2F</url>
    <content type="text"><![CDATA[如何将自定义类的实例化对象转换为JSON数据 我所用的方法是通过Runtime的相关方法，先后两步来实现的。具体往下看： 新建一个类命名为《UserClass》 展示.h文件UserClass.h 1234567891011121314// UserClass.h// MyPickerView// Created by LiynXu on 16/3/7.// Copyright © 2016年 LiynXu. All rights reserved.#import &lt;Foundation/Foundation.h&gt;@interface UserClass : NSObject@property (nonatomic,strong) NSString *name;@property (nonatomic,strong) NSString *password;@property (nonatomic,assign) NSInteger age;@property (nonatomic,strong) NSString *sex;- (instancetype)initWithName:(NSString *)name Password:(NSString *)password;- (NSDictionary *)convertToDictWithObject:(NSObject *)object;//主要使用这个方法得到一个字典@end 由上面的头文件可以看出我所建立的类有4个属性：name，password，age，sex。并且包含一个初始化方法，和对象转字典的方法(了解过Runtime，所以知道了Runtime可以在运行时某个对象的所有属性，以及属性的相关值) 具体实现方法 第一步将自定义类的实例化对象转为字典，这一步需要结合Runtime进行，所以我们需要做一个操作就是导入一个头文件 #import //当前需要使用使用运行时库 第二步使用第一部得到的字典转为JSON数据 1234567891011121314151617// UserClass.m// MyPickerView// Created by LiynXu on 16/3/7.// Copyright © 2016年 LiynXu. All rights reserved.#import &quot;UserClass.h&quot;#import &lt;objc/runtime.h&gt;//当前需要使用使用运行时库@implementation UserClass-(instancetype)initWithName:(NSString *)name Password:(NSString *)password&#123; self= [super init]; if (self) &#123; _name = name; _password = password; &#125; return self;&#125; 上面的主要是一个初始化方法，重要的是下面，下面，下面！ 1234567891011121314151617- (NSDictionary *)convertToDictWithObject:(NSObject *)object&#123;//获取当前对象的所有属性以及属性的值 NSMutableDictionary *Dict = [NSMutableDictionary dictionary]; unsigned int outCount, i; objc_property_t *properties = class_copyPropertyList([object class], &amp;outCount); //获取所有属性以及属性的值,并且转换为一个字典 for (i = 0; i&lt;outCount; i++)&#123; objc_property_t property = properties[i]; const char* char_f =property_getName(property); NSString *propertyName = [NSString stringWithUTF8String:char_f]; id propertyValue = [self valueForKey:(NSString *)propertyName]; if (propertyValue) [Dict setObject:propertyValue forKey:propertyName]; &#125; free(properties); return Dict;&#125;@end 程序入口main.m 包含具体示例代码 1234567891011121314151617181920212223242526272829303132//// main.m// JsonCode//// Created by LiynXu on 16/3/7.// Copyright © 2016年 LiynXu. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#import &quot;UserClass.h&quot;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; UserClass *user = [[UserClass alloc] initWithName:@&quot;name&quot; Password:@&quot;password&quot;]; NSDictionary *codeDict = [user convertToDictWithObject:user];//对象转字典， NSLog(@&quot;%@&quot;,codeDict); NSData *jsonData = [NSJSONSerialization dataWithJSONObject:codeDict options:NSJSONWritingPrettyPrinted error:nil];//字典转json code NSLog(@&quot;%@&quot;,jsonData); NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *path = [NSString stringWithFormat:@&quot;%@/Document/jsonData.json&quot;,NSHomeDirectory()]; BOOL res=[fileManager createFileAtPath:path contents:nil attributes:nil]; if (res) &#123; NSLog(@&quot;文件创建成功: %@&quot; ,path); &#125;else NSLog(@&quot;文件创建失败: %@&quot; ,path); NSString *jsonStrong = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; //json转字符串 NSLog(@&quot;%@&quot;,jsonStrong); NSDictionary *decodeDict = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableContainers error:nil]; //json Decode NSLog(@&quot;%@&quot;,decodeDict); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS自定义多选相册]]></title>
    <url>%2F2017%2F08%2F18%2FiOS--Custom_Ablum%2F</url>
    <content type="text"><![CDATA[自定义多选相册一个项目需要类似于安卓的多选相册，而iOS自带的Piker只能单选，所以就想到了自定义，自定义的过程是辛苦的，结果出来之后是高兴的。 &lt;!--more--&gt; 写在前面本代码只展示了iOS默认的相册内容，如果读者有其他想法的欢迎再本代码基础上修改。 获取系统默认的相册1234567-(PHFetchResult *)smartAlbums&#123; if (_smartAlbums == nil) &#123; _smartAlbums = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeSmartAlbum subtype:PHAssetCollectionSubtypeSmartAlbumUserLibrary options:nil]; &#125; return _smartAlbums;&#125; 获取系统相册中的相片默认的照片排序是时间先后顺序，这里我也规定了按照文件创建的先后顺序来排序呢，为了避免同时引用过多的image导致内存暴增，这里使用的都是缩略图，而且只允许引用前20项。 12345678910111213141516171819202122232425262728293031323334- (void)initPhotoData&#123; [self.photoArray removeAllObjects]; __weak typeof(self) weakSelf = self; for (PHCollection * obj in self.smartAlbums) &#123; if ([obj isKindOfClass:[PHAssetCollection class]]) &#123; PHAssetCollection *collection = (PHAssetCollection *)obj; PHFetchOptions *options = [[PHFetchOptions alloc] init]; options.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@&quot;creationDate&quot; ascending:NO]]; PHFetchResult *fetchReuslt = [PHAsset fetchAssetsInAssetCollection:collection options:options]; NSLog(@&quot;count - %ld&quot;,(unsigned long)fetchReuslt.count); if (fetchReuslt.count == 0) &#123; continue; &#125; NSInteger count = 20&lt;fetchReuslt.count?20:fetchReuslt.count; __block NSInteger _index = 0; for (NSInteger i = 0 ;i&lt;count;i++) &#123; PHAsset *asset = fetchReuslt[i]; //使用PHImageManager从PHAsset中请求图片 NSInteger index = _index; MyImageManager *imageManager = [MyImageManager defaultManager]; [imageManager requestImageForAsset:asset targetSize:CGSizeMake(ItemWidth()*2-2, ItemHieght()*2-2) contentMode:PHImageContentModeAspectFill options:self.requestOption Index:index resultHandler:^(UIImage *result, NSDictionary *info, NSInteger index) &#123; NSInteger IDKey = [info[@&quot;PHImageResultRequestIDKey&quot;] integerValue]; NSLog(@&quot;%@,%ld,%ld,%ld&quot;,result,(long)IDKey,index,IDKey-index); [weakSelf.photoArray addObject:result]; &#125;]; _index++; &#125; &#125;else&#123; NSLog(@&quot;NO&quot;); NSAssert1(NO, @&quot;Fetch Collect Not PHCollection:%@&quot;, obj); &#125; &#125; NSLog(@&quot;initPhotoDataDone&quot;);&#125; 将获取到的缩略图展示到CollectionView上 这个项目在码云的git库上有，地址为https://git.oschina.net/LiynXu/PhotoDemo.git。 如果有任何意见或者建议，或者发现bug(应该是有的),请移步值git库下给予指导，3Q。]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取iOS设备型号，截止到2018-9-21的所有iOS设备]]></title>
    <url>%2F2017%2F08%2F18%2FiOS--Get_iOS_Device_Model%2F</url>
    <content type="text"><![CDATA[获取iOS设备型号，截止到2018-9-21的所有iOS设备Objective-C下面是 UIDevice+UIDeviceExtension.h 文件 声明这个返回值为NSString的类方法 123456789101112#import &lt;UIKit/UIKit.h&gt;@interface UIDevice (UIDeviceExtension)/* 获取设备描述 */+ (NSString *)getCurrentDeviceModelDescription;/* 由获取到的设备描述，来匹配设备型号 */+ (NSString *)getCurrentDeviceModel;@end 获取设备具体详细的描述123456789101112131415+ (NSString *)getCurrentDeviceModelDescription&#123; int mib[2]; size_t len; char *machine; mib[0] = CTL_HW; mib[1] = HW_MACHINE; sysctl(mib, 2, NULL, &amp;len, NULL, 0); machine = malloc(len); sysctl(mib, 2, machine, &amp;len, NULL, 0); NSString *platform = [NSString stringWithCString:machine encoding:NSASCIIStringEncoding]; free(machine); return platform;&#125; 获取设备具体设备型号123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106+ (NSString *)getCurrentDeviceModel&#123; NSString *platform = [UIDevice getCurrentDeviceModelDescription]; if([platform isEqualToString:@&quot;iPhone3,1&quot;])return @&quot;iPhone 4&quot;; if([platform isEqualToString:@&quot;iPhone3,2&quot;])return @&quot;iPhone 4&quot;; if([platform isEqualToString:@&quot;iPhone3,3&quot;])return @&quot;iPhone 4&quot;; if([platform isEqualToString:@&quot;iPhone4,1&quot;])return @&quot;iPhone 4S&quot;; if([platform isEqualToString:@&quot;iPhone5,1&quot;])return @&quot;iPhone 5&quot;; if([platform isEqualToString:@&quot;iPhone5,2&quot;])return @&quot;iPhone 5(GSM+CDMA)&quot;; if([platform isEqualToString:@&quot;iPhone5,3&quot;])return @&quot;iPhone 5c(GSM)&quot;; if([platform isEqualToString:@&quot;iPhone5,4&quot;])return @&quot;iPhone 5c(GSM+CDMA)&quot;; if([platform isEqualToString:@&quot;iPhone6,1&quot;])return @&quot;iPhone 5s(GSM)&quot;; if([platform isEqualToString:@&quot;iPhone6,2&quot;])return @&quot;iPhone 5s(GSM+CDMA)&quot;; if([platform isEqualToString:@&quot;iPhone7,1&quot;])return @&quot;iPhone 6 Plus&quot;; if([platform isEqualToString:@&quot;iPhone7,2&quot;])return @&quot;iPhone 6&quot;; if([platform isEqualToString:@&quot;iPhone8,1&quot;])return @&quot;iPhone 6s&quot;; if([platform isEqualToString:@&quot;iPhone8,2&quot;])return @&quot;iPhone 6s Plus&quot;; if([platform isEqualToString:@&quot;iPhone8,4&quot;])return @&quot;iPhone SE&quot;; if([platform isEqualToString:@&quot;iPhone9,1&quot;])return @&quot;iPhone 7 国行、日版、港行&quot;; if([platform isEqualToString:@&quot;iPhone9,2&quot;])return @&quot;iPhone 7 Plus 港行、国行&quot;; if([platform isEqualToString:@&quot;iPhone9,3&quot;])return @&quot;iPhone 7 美版、台版&quot;; if([platform isEqualToString:@&quot;iPhone9,4&quot;])return @&quot;iPhone 7 Plus 美版、台版&quot;; if([platform isEqualToString:@&quot;iPhone10,1&quot;])return @&quot;iPhone 8 国行(A1863)、日行(A1906)&quot;; if([platform isEqualToString:@&quot;iPhone10,4&quot;])return @&quot;iPhone 8 美版(Global/A1905)&quot;; if([platform isEqualToString:@&quot;iPhone10,2&quot;])return @&quot;iPhone 8 Plus 国行(A1864)、日行(A1898)&quot;; if([platform isEqualToString:@&quot;iPhone10,5&quot;])return @&quot;iPhone 8 Plus 美版(Global/A1897)&quot;; if([platform isEqualToString:@&quot;iPhone10,3&quot;])return @&quot;iPhone X 国行(A1865)、日行(A1902)&quot;; if([platform isEqualToString:@&quot;iPhone10,6&quot;])return @&quot;iPhone X 美版(Global/A1901)&quot;; if ([platform isEqualToString:@&quot;iPhone11,2&quot;])return @&quot;iPhone XS&quot;; if ([platform isEqualToString:@&quot;iPhone11,6&quot;])return @&quot;iPhone XS Max&quot;; if ([platform isEqualToString:@&quot;iPhone11,8&quot;])return @&quot;iPhone XR&quot;; if([platform isEqualToString:@&quot;iPod1,1&quot;])return @&quot;iPod Touch 1G&quot;; if([platform isEqualToString:@&quot;iPod2,1&quot;])return @&quot;iPod Touch 2G&quot;; if([platform isEqualToString:@&quot;iPod3,1&quot;])return @&quot;iPod Touch 3G&quot;; if([platform isEqualToString:@&quot;iPod4,1&quot;])return @&quot;iPod Touch 4G&quot;; if([platform isEqualToString:@&quot;iPod5,1&quot;])return @&quot;iPod Touch(5 Gen)&quot;; if([platform isEqualToString:@&quot;iPad1,1&quot;])return @&quot;iPad&quot;; if([platform isEqualToString:@&quot;iPad1,2&quot;])return @&quot;iPad 3G&quot;; if([platform isEqualToString:@&quot;iPad2,1&quot;])return @&quot;iPad 2(WiFi)&quot;; if([platform isEqualToString:@&quot;iPad2,2&quot;])return @&quot;iPad 2&quot;; if([platform isEqualToString:@&quot;iPad2,3&quot;])return @&quot;iPad 2(CDMA)&quot;; if([platform isEqualToString:@&quot;iPad2,4&quot;])return @&quot;iPad 2&quot;; if([platform isEqualToString:@&quot;iPad2,5&quot;])return @&quot;iPad Mini(WiFi)&quot;; if([platform isEqualToString:@&quot;iPad2,6&quot;])return @&quot;iPad Mini&quot;; if([platform isEqualToString:@&quot;iPad2,7&quot;])return @&quot;iPad Mini(GSM+CDMA)&quot;; if([platform isEqualToString:@&quot;iPad3,1&quot;])return @&quot;iPad 3(WiFi)&quot;; if([platform isEqualToString:@&quot;iPad3,2&quot;])return @&quot;iPad 3(GSM+CDMA)&quot;; if([platform isEqualToString:@&quot;iPad3,3&quot;])return @&quot;iPad 3&quot;; if([platform isEqualToString:@&quot;iPad3,4&quot;])return @&quot;iPad 4(WiFi)&quot;; if([platform isEqualToString:@&quot;iPad3,5&quot;])return @&quot;iPad 4&quot;; if([platform isEqualToString:@&quot;iPad3,6&quot;])return @&quot;iPad 4(GSM+CDMA)&quot;; if([platform isEqualToString:@&quot;iPad4,1&quot;])return @&quot;iPad Air(WiFi)&quot;; if([platform isEqualToString:@&quot;iPad4,2&quot;])return @&quot;iPad Air(Cellular)&quot;; if([platform isEqualToString:@&quot;iPad4,4&quot;])return @&quot;iPad Mini 2(WiFi)&quot;; if([platform isEqualToString:@&quot;iPad4,5&quot;])return @&quot;iPad Mini 2(Cellular)&quot;; if([platform isEqualToString:@&quot;iPad4,6&quot;])return @&quot;iPad Mini 2&quot;; if([platform isEqualToString:@&quot;iPad4,7&quot;])return @&quot;iPad Mini 3&quot;; if([platform isEqualToString:@&quot;iPad4,8&quot;])return @&quot;iPad Mini 3&quot;; if([platform isEqualToString:@&quot;iPad4,9&quot;])return @&quot;iPad Mini 3&quot;; if([platform isEqualToString:@&quot;iPad5,1&quot;])return @&quot;iPad Mini 4(WiFi)&quot;; if([platform isEqualToString:@&quot;iPad5,2&quot;])return @&quot;iPad Mini 4(LTE)&quot;; if([platform isEqualToString:@&quot;iPad5,3&quot;])return @&quot;iPad Air 2&quot;; if([platform isEqualToString:@&quot;iPad5,4&quot;])return @&quot;iPad Air 2&quot;; if([platform isEqualToString:@&quot;iPad6,3&quot;])return @&quot;iPad Pro 9.7&quot;; if([platform isEqualToString:@&quot;iPad6,4&quot;])return @&quot;iPad Pro 9.7&quot;; if([platform isEqualToString:@&quot;iPad6,7&quot;])return @&quot;iPad Pro 12.9&quot;; if([platform isEqualToString:@&quot;iPad6,8&quot;])return @&quot;iPad Pro 12.9&quot;; if([platform isEqualToString:@&quot;iPad6,11&quot;])return @&quot;iPad 5(WiFi)&quot;; if([platform isEqualToString:@&quot;iPad6,12&quot;])return @&quot;iPad 5(Cellular)&quot;; if([platform isEqualToString:@&quot;iPad7,1&quot;])return @&quot;iPad Pro 12.9 inch 2nd gen(WiFi)&quot;; if([platform isEqualToString:@&quot;iPad7,2&quot;])return @&quot;iPad Pro 12.9 inch 2nd gen(Cellular)&quot;; if([platform isEqualToString:@&quot;iPad7,3&quot;])return @&quot;iPad Pro 10.5 inch(WiFi)&quot;; if([platform isEqualToString:@&quot;iPad7,4&quot;])return @&quot;iPad Pro 10.5 inch(Cellular)&quot;; if([platform isEqualToString:@&quot;AppleTV2,1&quot;])return @&quot;Apple TV 2&quot;; if([platform isEqualToString:@&quot;AppleTV3,1&quot;])return @&quot;Apple TV 3&quot;; if([platform isEqualToString:@&quot;AppleTV3,2&quot;])return @&quot;Apple TV 3&quot;; if([platform isEqualToString:@&quot;AppleTV5,3&quot;])return @&quot;Apple TV 4&quot;; if([platform isEqualToString:@&quot;i386&quot;])return @&quot;Simulator&quot;; if([platform isEqualToString:@&quot;x86_64&quot;])return @&quot;Simulator&quot;; return platform;&#125; 如何使用首先在.m文件中导入以下两个头文件 12#import &quot;UIDevice+UIDeviceExtension.h&quot;#import &lt;sys/sysctl.h&gt; 然后在需要获取设备型号地方这样写,用一个NSString类型的对象接收 1234NSString *string = [UIDevice getCurrentDeviceModel];NSLog(@&quot;设备型号:%@&quot;,string);NSString *string =[UIDevice getCurrentDeviceModelDescription];NSLog(@&quot;设备描述:%@&quot;,string); Swift获取设备具体详细的描述1234567891011121314151617181920//获取设备具体详细的描述 public class func getCurrentDeviceModelDescription() -&gt; String &#123; var systemInfo = utsname() uname(&amp;systemInfo) let machineMirror = Mirror(reflecting: systemInfo.machine) let identifierDescription = machineMirror.children.reduce(&quot;&quot;) &#123; identifier, element in guard let value = element.value as? Int8, value != 0 else &#123; return identifier &#125; let identifierDescription = identifier + String(UnicodeScalar(UInt8(value))) return identifierDescription; &#125; return identifierDescription &#125; 获取设备具体型号12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//获取设备具体型号 public class func getCurrentDeviceModel() -&gt; String&#123; let identifier = UIDevice.getCurrentDeviceModelDescription() switch identifier &#123; case &quot;iPod5,1&quot;: return &quot;iPod Touch 5&quot; case &quot;iPod7,1&quot;: return &quot;iPod Touch 6&quot; case &quot;iPhone3,1&quot;, &quot;iPhone3,2&quot;, &quot;iPhone3,3&quot;: return &quot;iPhone 4&quot; case &quot;iPhone4,1&quot;: return &quot;iPhone 4s&quot; case &quot;iPhone5,1&quot;, &quot;iPhone5,2&quot;: return &quot;iPhone 5&quot; case &quot;iPhone5,3&quot;, &quot;iPhone5,4&quot;: return &quot;iPhone 5c&quot; case &quot;iPhone6,1&quot;, &quot;iPhone6,2&quot;: return &quot;iPhone 5s&quot; case &quot;iPhone7,2&quot;: return &quot;iPhone 6&quot; case &quot;iPhone7,1&quot;: return &quot;iPhone 6 Plus&quot; case &quot;iPhone8,1&quot;: return &quot;iPhone 6s&quot; case &quot;iPhone8,2&quot;: return &quot;iPhone 6s Plus&quot; case &quot;iPhone8,4&quot;: return &quot;iPhone SE&quot; case &quot;iPhone9,1&quot;: return &quot;iPhone 7 (CDMA)&quot; case &quot;iPhone9,3&quot;: return &quot;iPhone 7 (GSM)&quot; case &quot;iPhone9,2&quot;: return &quot;iPhone 7 Plus (CDMA)&quot; case &quot;iPhone9,4&quot;: return &quot;iPhone 7 Plus (GSM)&quot; case &quot;iPhone10,1&quot;, &quot;iPhone10,4&quot;: return &quot;iPhone 8&quot; case &quot;iPhone10,2&quot;, &quot;iPhone10,5&quot;: return &quot;iPhone 8 Plus&quot; case &quot;iPhone10,3&quot;, &quot;iPhone10,6&quot;: return &quot;iPhone X&quot; case &quot;iPhone11,2&quot;: return &quot;iPhone XS&quot; case &quot;iPhone11,6&quot;: return &quot;iPhone XS Max&quot; case &quot;iPhone11,8&quot;: return &quot;iPhone XR&quot; case &quot;iPad2,1&quot;, &quot;iPad2,2&quot;, &quot;iPad2,3&quot;, &quot;iPad2,4&quot;:return &quot;iPad 2&quot; case &quot;iPad3,1&quot;, &quot;iPad3,2&quot;, &quot;iPad3,3&quot;: return &quot;iPad 3&quot; case &quot;iPad3,4&quot;, &quot;iPad3,5&quot;, &quot;iPad3,6&quot;: return &quot;iPad 4&quot; case &quot;iPad4,1&quot;, &quot;iPad4,2&quot;, &quot;iPad4,3&quot;: return &quot;iPad Air&quot; case &quot;iPad5,3&quot;, &quot;iPad5,4&quot;: return &quot;iPad Air 2&quot; case &quot;iPad2,5&quot;, &quot;iPad2,6&quot;, &quot;iPad2,7&quot;: return &quot;iPad Mini&quot; case &quot;iPad4,4&quot;, &quot;iPad4,5&quot;, &quot;iPad4,6&quot;: return &quot;iPad Mini 2&quot; case &quot;iPad4,7&quot;, &quot;iPad4,8&quot;, &quot;iPad4,9&quot;: return &quot;iPad Mini 3&quot; case &quot;iPad5,1&quot;, &quot;iPad5,2&quot;: return &quot;iPad Mini 4&quot; case &quot;iPad6,7&quot;, &quot;iPad6,8&quot;: return &quot;iPad Pro&quot; case &quot;AppleTV5,3&quot;: return &quot;Apple TV&quot; case &quot;i386&quot;, &quot;x86_64&quot;: return &quot;Simulator&quot; default: return identifier &#125; &#125; 完整代码演示：https://git.oschina.net/LiynXu/GetDeviceModel.git 欢迎访问！ 效果展示： 相关链接 简书： https://www.jianshu.com/p/14b565a0f455 CDSN： https://blog.csdn.net/ZuoWeiXiaoDuZuoZuo/article/details/49945157 ilongge.cn： http://ilongge.cn/2017/08/18/iOS--Get_iOS_Device_Model/]]></content>
  </entry>
  <entry>
    <title><![CDATA[解除百度网盘下载限速]]></title>
    <url>%2F2017%2F08%2F09%2FRelease_BaiduNetDisk_Downloading_Speed_Limit%2F</url>
    <content type="text"><![CDATA[众所周知的百度网盘为了迫使用户花钱，对用户的下载速度做出了限制。今天我就来分享一个破解限制的好办法，这个也是网上扒来的。 准备工作1、下载相关资料，也就是两个文件：http://pan.baidu.com/s/1nuPgpNN 2、安装chrome浏览器 3、安装下载的Aria2GUI 1.3.7.dmg 4、安装chrome插件BaiduExporter.zip 解压这个zip文件，然后打开chrome， 使用1、打开刚刚安装的Aria2GUI客户端 2、在chrome里面打开百度云网页,插件安装成功网页上就会多出一个“导出下载”的按钮 3、找到你要下载的文件，并且勾选文件（这里最好先把文件存入自己的网盘目录）,然后点击ARIA2 RPC下载任务就会被客户端执行 4、看一下速度 ATTENSION！！！本项目是MAC OS专用的，windows的目前不清楚安装chrome插件之后,插件原文件就不能移动位置,更不能删除,否则插件就会失效.]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS10富文本推送--UIMutableUserNotificationAction]]></title>
    <url>%2F2017%2F07%2F18%2FiOS10%E5%AF%8C%E6%96%87%E6%9C%AC%E6%8E%A8%E9%80%81--UIMutableUserNotificationAction%2F</url>
    <content type="text"><![CDATA[iOS10富文本推送–UIMutableUserNotificationAction AppDelagate文件添加action根据以下ContentExtension Info.plist文件中的配置决定category的设置，两者必须一致 宏定义采用下列代码： 12345678910111213141516//推送相关设置#define Action_Category_Identifier_Image @&quot;Image_Category&quot; //图片类别标识符#define Action_Category_Identifier_Audio @&quot;Audio_Category&quot; //音频类别标识符#define Action_Category_Identifier_Movie @&quot;Movie_Category&quot; //视频类别标识符#define Action_Identifier_Image_Confirm @&quot;imageConfirmAction&quot; //图片确认按钮#define Action_Identifier_Image_Concel @&quot;imageConcelAction&quot; //图片取消按钮#define Action_Identifier_Audio_Confirm @&quot;audioConfirmAction&quot; //音频确认按钮#define Action_Identifier_Audio_Concel @&quot;audioConcelAction&quot; //音频取消按钮#define Action_Identifier_Movie_Confirm @&quot;movieConfirmAction&quot; //视频确认按钮#define Action_Identifier_Movie_Concel @&quot;movieConcelAction&quot; //视频取消按钮#define Action_Title_Image_Confirm @&quot;查看&quot; //图片确认按钮标题#define Action_Title_Image_Concel @&quot;忽略&quot; //图片取消按钮标题#define Action_Title_Audio_Confirm @&quot;查看&quot; //音频确认按钮标题#define Action_Title_Audio_Concel @&quot;忽略&quot; //音频取消按钮标题#define Action_Title_Movie_Confirm @&quot;查看&quot; //视频确认按钮标题#define Action_Title_Movie_Concel @&quot;忽略&quot; //视频取消按钮标题 添加相应类别的aciton，一个类别必须对应一个category，在下面这个方法里面执行,1- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//添加相应类别的aciton，一个类别必须对应一个category- (void)addNotificationAction&#123; //Image_Category UIMutableUserNotificationAction *imageConfirmAction = [self creatNotificationActionIdentifier:Action_Identifier_Image_Confirm title:Action_Title_Image_Confirm activationMode:UIUserNotificationActivationModeForeground]; imageConfirmAction.authenticationRequired = YES; imageConfirmAction.destructive = YES; UIMutableUserNotificationAction *imageConcelAction = [self creatNotificationActionIdentifier:Action_Identifier_Image_Concel title:Action_Title_Image_Concel activationMode:UIUserNotificationActivationModeBackground]; UIMutableUserNotificationCategory *ImageCategory = [self creatNotificationCategoryIdentifier:Action_Category_Identifier_Image setActions:@[imageConfirmAction,imageConcelAction] forContext:UIUserNotificationActionContextDefault]; //Audio_Category UIMutableUserNotificationAction *audioConfirmAction = [self creatNotificationActionIdentifier:Action_Identifier_Audio_Confirm title:Action_Title_Audio_Confirm activationMode:UIUserNotificationActivationModeForeground]; audioConfirmAction.authenticationRequired = YES; audioConfirmAction.destructive = YES; UIMutableUserNotificationAction *audioConcelAction = [self creatNotificationActionIdentifier:Action_Identifier_Audio_Concel title:Action_Title_Audio_Concel activationMode:UIUserNotificationActivationModeBackground]; UIMutableUserNotificationCategory *audioCategory = [self creatNotificationCategoryIdentifier:Action_Category_Identifier_Audio setActions:@[audioConfirmAction,audioConcelAction] forContext:UIUserNotificationActionContextDefault]; //Movie_Category UIMutableUserNotificationAction *movieConfirmAction = [self creatNotificationActionIdentifier:Action_Identifier_Movie_Confirm title:Action_Title_Movie_Confirm activationMode:UIUserNotificationActivationModeForeground]; movieConfirmAction.authenticationRequired = YES; movieConfirmAction.destructive = YES; UIMutableUserNotificationAction *movieConcelAction = [self creatNotificationActionIdentifier:Action_Identifier_Movie_Concel title:Action_Title_Movie_Concel activationMode:UIUserNotificationActivationModeBackground]; UIMutableUserNotificationCategory *movieCategory = [self creatNotificationCategoryIdentifier:Action_Category_Identifier_Movie setActions:@[movieConfirmAction,movieConcelAction] forContext:UIUserNotificationActionContextDefault]; NSSet *categories = [NSSet setWithObjects:ImageCategory,audioCategory,movieCategory,nil]; UIUserNotificationType types = (UIUserNotificationTypeAlert| UIUserNotificationTypeSound| UIUserNotificationTypeBadge); UIUserNotificationSettings *settings; settings = [UIUserNotificationSettings settingsForTypes:types categories:categories]; [[UIApplication sharedApplication] registerUserNotificationSettings:settings]; &#125; 创建一个category 12345678910//创建一个category- (UIMutableUserNotificationCategory*)creatNotificationCategoryIdentifier:(NSString *)identifier setActions:(nullable NSArray&lt;UIUserNotificationAction *&gt; *)actions forContext:(UIUserNotificationActionContext)context&#123; UIMutableUserNotificationCategory *category = [[UIMutableUserNotificationCategory alloc] init]; category.identifier = identifier;//这组动作的唯一标示 [category setActions:actions forContext:context]; return category;&#125; 创建一个action 1234567891011//创建一个action-(UIMutableUserNotificationAction *)creatNotificationActionIdentifier:(NSString *)identifier title:(NSString *)title activationMode:(UIUserNotificationActivationMode)activationMode&#123; UIMutableUserNotificationAction *action = [[UIMutableUserNotificationAction alloc] init]; //第二按钮 action.identifier = identifier; action.title = title; action.activationMode = activationMode; return action;&#125;]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS10富文本推送--NotificationServiceExtension]]></title>
    <url>%2F2017%2F07%2F18%2FiOS10%E5%AF%8C%E6%96%87%E6%9C%AC%E6%8E%A8%E9%80%81--NotificationServiceExtension%2F</url>
    <content type="text"><![CDATA[添加http协议支持，没错，这里是支持http协议的，不像其他文章说的不支持配置在另外基础篇文章里面有，info.plist文件里修改一下就行了 NotificationService文件额外添加了一个文件管理器的字段，用来存储数据 1234567891011@interface NotificationService ()@property (nonatomic, strong) void (^contentHandler)(UNNotificationContent *contentToDeliver);@property (nonatomic, strong) UNMutableNotificationContent *bestAttemptContent;@property (nonatomic, strong) NSFileManager *fileMgr;@property (nonatomic, strong) NSURLSessionDownloadTask *download;@property (nonatomic, strong) NSURLSession *session;@property (nonatomic, strong) NSDictionary *userInfo;@property (nonatomic, strong) NSURL *attchUrl;@property (nonatomic, strong) NSString *imageExtension;@end 1@implementation NotificationService LazyLoad 123-(NSFileManager *)fileMgr&#123; return [NSFileManager defaultManager];&#125; 网络session 123456-(NSURLSession *)session&#123; if (_session == nil) &#123; _session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; &#125; return _session;&#125; 下载任务 123456789101112131415161718192021222324-(NSURLSessionDownloadTask *)download&#123; if (!_download) &#123; _download = [self.session downloadTaskWithURL:self.attchUrl completionHandler:^(NSURL * _Nullable tempLocation, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (!error) &#123; NSURL *localURL = [NSURL fileURLWithPath:[tempLocation.path stringByAppendingString:self.imageExtension]]; [self.fileMgr moveItemAtURL:tempLocation toURL:localURL error:&amp;error]; NSError *attachmentError = nil; UNNotificationAttachment * attachment = [UNNotificationAttachment attachmentWithIdentifier:@&quot;photo&quot; URL:localURL options:nil error:&amp;attachmentError]; if (attachmentError) &#123; NSLog(@&quot;attachmentError %@&quot;,attachmentError); &#125;else if (attachment)&#123; self.bestAttemptContent.attachments = @[attachment]; &#125;else&#123; &#125; &#125;else&#123; NSLog(@&quot;downloadTaskerror %@&quot;,error.localizedDescription); &#125; self.bestAttemptContent.categoryIdentifier = self.userInfo[@&quot;aps&quot;][@&quot;category&quot;]; self.contentHandler(self.bestAttemptContent); &#125;]; &#125; return _download;&#125; 收到远程通知之后，在当前方法内进行处理，并生成attchment，最终回调给系统 123456789101112- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler &#123; self.contentHandler = contentHandler; self.bestAttemptContent = [request.content mutableCopy]; self.resumeTime = 0; self.userInfo = [request.content.userInfo copy]; NSString * attchUrl = self.userInfo[@&quot;image&quot;]; self.imageExtension = [NSString stringWithFormat:@&quot;.%@&quot;,[[attchUrl componentsSeparatedByString:@&quot;.&quot;] lastObject]]; if (attchUrl) &#123; self.attchUrl = [NSURL URLWithString:attchUrl]; [self resumeSession]; &#125;&#125; 开始执行下载多媒体资源任务 123- (void)resumeSession&#123; [self.download resume];&#125; 超时，异常时调用 123456789- (void)serviceExtensionTimeWillExpire &#123; // Called just before the extension will be terminated by the system. // Use this as an opportunity to deliver your &quot;best attempt&quot; at modified content, otherwise the original push payload will be used. self.contentHandler(self.bestAttemptContent);&#125;@end]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS10富文本推送--NotificationContentExtension]]></title>
    <url>%2F2017%2F07%2F18%2FiOS10%E5%AF%8C%E6%96%87%E6%9C%AC%E6%8E%A8%E9%80%81--NotificationContentExtension%2F</url>
    <content type="text"><![CDATA[NotificationContentExtension文件根据以下ContentExtension Info.plist文件中的配置决定category的设置，两者必须一致： NSExtensionPrincipalClass对应的值是你展示视图的controller（这里就是NotificationViewController） 宏定义采用下列代码： 12345678910111213141516//推送相关设置#define Action_Category_Identifier_Image @&quot;Image_Category&quot; //图片类别标识符#define Action_Category_Identifier_Audio @&quot;Audio_Category&quot; //音频类别标识符#define Action_Category_Identifier_Movie @&quot;Movie_Category&quot; //视频类别标识符#define Action_Identifier_Image_Confirm @&quot;imageConfirmAction&quot; //图片确认按钮#define Action_Identifier_Image_Concel @&quot;imageConcelAction&quot; //图片取消按钮#define Action_Identifier_Audio_Confirm @&quot;audioConfirmAction&quot; //音频确认按钮#define Action_Identifier_Audio_Concel @&quot;audioConcelAction&quot; //音频取消按钮#define Action_Identifier_Movie_Confirm @&quot;movieConfirmAction&quot; //视频确认按钮#define Action_Identifier_Movie_Concel @&quot;movieConcelAction&quot; //视频取消按钮#define Action_Title_Image_Confirm @&quot;查看&quot; //图片确认按钮标题#define Action_Title_Image_Concel @&quot;忽略&quot; //图片取消按钮标题#define Action_Title_Audio_Confirm @&quot;查看&quot; //音频确认按钮标题#define Action_Title_Audio_Concel @&quot;忽略&quot; //音频取消按钮标题#define Action_Title_Movie_Confirm @&quot;查看&quot; //视频确认按钮标题#define Action_Title_Movie_Concel @&quot;忽略&quot; //视频取消按钮标题 采用的是自定义布局，注意如果想使用这个布局的话，你必须提前在service里面设置好categoryIdentifier，它的值是你plist文件里面的任何一个 1234@interface NotificationViewController () &lt;UNNotificationContentExtension&gt;@property (nonatomic, strong)UIImageView *imageView;@property (nonatomic,strong)UILabel *label;@end LazyLoad 1234567-(UIImageView *)imageView&#123; if (_imageView == nil) &#123; _imageView = [[UIImageView alloc] init]; _imageView.contentMode = UIViewContentModeScaleAspectFit; &#125; return _imageView;&#125; AddView 12345- (void)viewDidLoad &#123; [super viewDidLoad]; [self.view addSubview:self.imageView]; // Do any required interface initialization here.&#125; 取出多媒体资料并展示到视图上，下面为image 123456789101112131415161718- (void)didReceiveNotification:(UNNotification *)notification &#123; NSLog(@&quot;notification.request.content.userInfo%@&quot;,notification.request.content.userInfo); UNNotificationContent * content = notification.request.content; CGFloat widthTime = 2; if ([UIScreen mainScreen].bounds.size.width&gt;375) &#123; widthTime = 3.0; &#125; UIImage *image = nil; if (content.attachments.count) &#123; UNNotificationAttachment * attachment_img = content.attachments[0]; if (attachment_img.URL.startAccessingSecurityScopedResource) &#123; image = [UIImage imageWithContentsOfFile:attachment_img.URL.path]; self.imageView.image = image; &#125; &#125; self.imageView.frame = self.view.frame; self.label.text = notification.request.content.body;&#125; 响应相关Action 12345678910111213141516171819202122232425-(void)didReceiveNotificationResponse:(UNNotificationResponse *)response completionHandler:(void (^)(UNNotificationContentExtensionResponseOption))completion&#123; UNNotificationContent *content = [response.notification.request.content mutableCopy]; NSString *category = content.categoryIdentifier; NSString *actionIdentifier = [response.actionIdentifier copy]; if ([category isEqualToString:Action_Category_Identifier_Image]) &#123; if ([actionIdentifier isEqualToString:Action_Identifier_Image_Confirm]) &#123; completion(UNNotificationContentExtensionResponseOptionDismissAndForwardAction); &#125;else&#123; completion(UNNotificationContentExtensionResponseOptionDismiss); &#125; &#125;else if ([category isEqualToString:Action_Category_Identifier_Audio])&#123; if ([actionIdentifier isEqualToString:Action_Identifier_Audio_Confirm]) &#123; completion(UNNotificationContentExtensionResponseOptionDismissAndForwardAction); &#125;else&#123; completion(UNNotificationContentExtensionResponseOptionDismiss); &#125; &#125;else&#123; if ([actionIdentifier isEqualToString:Action_Identifier_Movie_Confirm]) &#123; completion(UNNotificationContentExtensionResponseOptionDismissAndForwardAction); &#125;else&#123; completion(UNNotificationContentExtensionResponseOptionDismiss); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD语法]]></title>
    <url>%2F2017%2F07%2F14%2FMD%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[MacDown Hello there! I’m MacDown, the open source Markdown editor for OS X. Let me introduce myself. Markdown and IMarkdown is a plain text formatting syntax created by John Gruber, aiming to provide a easy-to-read and feasible markup. The original Markdown syntax specification can be found here. MacDown is created as a simple-to-use editor for Markdown documents. I render your Markdown contents real-time into HTML, and display them in a preview panel. I support all the original Markdown syntaxes. But I can do so much more! Various popular but non-standard syntaxes can be turned on/off from the Markdown preference pane. You can specify extra HTML rendering options through the Rendering preference pane. You can customize the editor window to you liking in the Editor preferences pane: You can configure various application (that’s me!) behaviors in the General preference pane. The BasicsBefore I tell you about all the extra syntaxes and capabilities I have, I’ll introduce you to the basics of standard markdown. If you already know markdown, and want to jump straight to learning about the fancier things I can do, I suggest you skip to the Markdown preference pane. Lets jump right in. Line BreaksTo force a line break, put two spaces and a newline (return) at the end of the line. This two-line bulletwon’t break This two-line bulletwill break Here is the code: 12345* This two-line bullet won&apos;t break* This two-line bullet will break Strong and EmphasizeStrong: **Strong** or __Strong__ (Command-B)Emphasize: *Emphasize* or _Emphasize_[^emphasize] (Command-I) Headers (like this one!)Header 1 ======== Header 2 -------- or # Header 1 ## Header 2 ### Header 3 #### Header 4 ##### Header 5 ###### Header 6 Links and EmailInlineJust put angle brackets around an email and it becomes clickable: &#117;&#114;&#x61;&#x6e;&#x75;&#115;&#106;&#114;&#64;&#103;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#x6d;&lt;uranusjr@gmail.com&gt; Same thing with urls: http://macdown.uranusjr.com&lt;http://macdown.uranusjr.com&gt; Perhaps you want to some link text like this: Macdown Website[Macdown Website](http://macdown.uranusjr.com &quot;Title&quot;) (The title is optional) Reference styleSometimes it looks too messy to include big long urls inline, or you want to keep all your urls together. Make a link [a link][arbitrary_id] then on it’s own line anywhere else in the file:[arbitrary_id]: http://macdown.uranusjr.com &quot;Title&quot; If the link text itself would make a good id, you can link like this [like this][], then on it’s own line anywhere else in the file:[like this]: http://macdown.uranusjr.com ImagesInline![Alt Image Text](path/or/url/to.jpg &quot;Optional Title&quot;) Reference style![Alt Image Text][image-id]on it’s own line elsewhere:[image-id]: path/or/url/to.jpg &quot;Optional Title&quot; Lists Lists must be preceded by a blank line (or block element) Unordered lists start each item with a * - works too Indent a level to make a nested list Ordered lists are supported. Start each item (number-period-space) like 1. It doesn’t matter what number you use, I will render them sequentially So you might want to start each line with 1. and let me sort it out Here is the code: 12345678* Lists must be preceded by a blank line (or block element)* Unordered lists start each item with a `*`- `-` works too * Indent a level to make a nested list 1. Ordered lists are supported. 2. Start each item (number-period-space) like `1. ` 42. It doesn&apos;t matter what number you use, I will render them sequentially 1. So you might want to start each line with `1.` and let me sort it out Block Quote Angle brackets &gt; are used for block quotes.Technically not every line needs to start with a &gt; as long asthere are no empty lines between paragraphs.Looks kinda ugly though. Block quotes can be nested. Multiple Levels Most markdown syntaxes work inside block quotes. Lists Links Etc. Here is the code: 123456789101112&gt; Angle brackets `&gt;` are used for block quotes. Technically not every line needs to start with a `&gt;` as long asthere are no empty lines between paragraphs. &gt; Looks kinda ugly though.&gt; &gt; Block quotes can be nested. &gt; &gt; &gt; Multiple Levels&gt;&gt; Most markdown syntaxes work inside block quotes.&gt;&gt; * Lists&gt; * [Links][arbitrary_id]&gt; * Etc. Inline CodeInline code is indicated by surrounding it with backticks:`Inline code` If your code has `backticks` that need to be displayed, you can use double backticks:``Code with `backticks` `` ```` (mind the spaces preceding the final set of backticks)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950### Block CodeIf you indent at least four spaces or one tab, I&apos;ll display a code block. print(&apos;This is a code block&apos;) print(&apos;The block must be preceded by a blank line&apos;) print(&apos;Then indent at least 4 spaces or 1 tab&apos;) print(&apos;Nesting does nothing. Your code is displayed Literally&apos;)I also know how to do something called [Fenced Code Blocks](#fenced-code-block) which I will tell you about later.### Horizontal RulesIf you type three asterisks `***` or three dashes `---` on a line, I&apos;ll display a horizontal rule:***## &lt;a name=&quot;markdown-pane&quot;&gt;&lt;/a&gt;The Markdown Preference PaneThis is where I keep all preferences related to how I parse markdown into html. ![Markdown preferences pane](http://d.pr/i/RQEi+)### Document FormattingThe ***Smartypants*** extension automatically transforms straight quotes (`&quot;` and `&apos;`) in your text into typographer’s quotes (`“`, `”`, `‘`, and `’`) according to the context. Very useful if you’re a typography freak like I am. Quote and Smartypants are syntactically incompatible. If both are enabled, Quote takes precedence.### Block Formatting#### TableThis is a table:First Header | Second Header------------- | -------------Content Cell | Content CellContent Cell | Content CellYou can align cell contents with syntax like this:| Left Aligned | Center Aligned | Right Aligned ||:------------- |:---------------:| -------------:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 |The left- and right-most pipes (`|`) are only aesthetic, and can be omitted. The spaces don’t matter, either. Alignment depends solely on `:` marks.#### &lt;a name=&quot;fenced-code-block&quot;&gt;Fenced Code Block&lt;/a&gt;This is a fenced code block: print(‘Hello world!’)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071You can also use waves (`~`) instead of back ticks (`` ` ``):~~~print(&apos;Hello world!&apos;)~~~You can add an optional language ID at the end of the first line. The language ID will only be used to highlight the code inside if you tick the ***Enable highlighting in code blocks*** option. This is what happens if you enable it:![Syntax highlighting example](http://d.pr/i/9HM6+)I support many popular languages as well as some generic syntax descriptions that can be used if your language of choice is not supported. See [relevant sections on the official site](http://macdown.uranusjr.com/features/) for a full list of supported syntaxes.### Inline FormattingThe following is a list of optional inline markups supported:Option name | Markup | Result if enabled |--------------------|------------------|-----------------------|Intra-word emphasis | So A\*maz\*ing | So A&lt;em&gt;maz&lt;/em&gt;ing |Strikethrough | \~~Much wow\~~ | &lt;del&gt;Much wow&lt;/del&gt; |Underline [^under] | \_So doge\_ | &lt;u&gt;So doge&lt;/u&gt; |Quote [^quote] | \&quot;Such editor\&quot; | &lt;q&gt;Such editor&lt;/q&gt; |Highlight | \==So good\== | &lt;mark&gt;So good&lt;/mark&gt; |Superscript | hoge\^(fuga) | hoge&lt;sup&gt;fuga&lt;/sup&gt; |Autolink | http://t.co | &lt;http://t.co&gt; |Footnotes | [\^4] and [\^4]: | [^4] and footnote 4 |[^4]: You don&apos;t have to use a number. Arbitrary things like `[^footy note4]` and `[^footy note4]:` will also work. But they will *render* as numbered footnotes. Also, no need to keep your footnotes in order, I will sort out the order for you so they appear in the same order they were referenced in the text body. You can even keep some footnotes near where you referenced them, and collect others at the bottom of the file in the traditional place for footnotes. ## &lt;a name=&quot;rendering-pane&quot;&gt;&lt;/a&gt;The Rendering Preference PaneThis is where I keep preferences relating to how I render and style the parsed markdown in the preview window. ![Rendering preferences pane](http://d.pr/i/rT4d+)### CSSYou can choose different css files for me to use to render your html. You can even customize or add your own custom css files.### Syntax HighlightingYou have already seen how I can syntax highlight your fenced code blocks. See the [Fenced Code Block](#fenced-code-block) section if you haven’t! You can also choose different themes for syntax highlighting.### TeX-like Math SyntaxI can also render TeX-like math syntaxes, if you allow me to.[^math] I can do inline math like this: \\( 1 + 1 \\) or this (in MathML): &lt;math&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;, and block math:\\[ A^T_S = B\\]or (in MathML)&lt;math display=&quot;block&quot;&gt; &lt;msubsup&gt;&lt;mi&gt;A&lt;/mi&gt; &lt;mi&gt;S&lt;/mi&gt; &lt;mi&gt;T&lt;/mi&gt;&lt;/msubsup&gt; &lt;mo&gt;=&lt;/mo&gt; &lt;mi&gt;B&lt;/mi&gt;&lt;/math&gt;### Task List Syntax1. [x] I can render checkbox list syntax * [x] I support nesting * [x] I support ordered *and* unordered lists2. [ ] I don&apos;t support clicking checkboxes directly in the html window### Jekyll front-matterIf you like, I can display Jekyll front-matter in a nice table. Just make sure you put the front-matter at the very beginning of the file, and fence it with `---`. For example: title: “Macdown is my friend” date: 2014-06-06 20:00:00``` Render newline literallyNormally I require you to put two spaces and a newline (aka return) at the end of a line in order to create a line break. If you like, I can render a newline any time you end a line with a newline. However, if you enable this, markdown that looks lovely when I render it might look pretty funky when you let some other program render it. The General Preferences PaneThis is where I keep preferences related to application behavior. The General Preferences Pane allows you to tell me how you want me to behave. For example, do you want me to make sure there is a document open when I launch? You can also tell me if I should constantly update the preview window as you type, or wait for you to hit command-R instead. Maybe you prefer your editor window on the right? Or to see the word-count as you type. This is also the place to tell me if you are interested in pre-releases of me, or just want to stick to better-tested official releases. The Editor Preference PaneThis is where I keep preferences related to the behavior and styling of the editing window. StylingMy editor provides syntax highlighting. You can edit the base font and the coloring/sizing theme. I provided some default themes (courtesy of Mou’s creator, Chen Luo) if you don’t know where to start. You can also edit, or even add new themes if you want to! Just click the Reveal button, and start moving things around. Remember to use the correct file extension (.styles), though. I’m picky about that. I offer auto-completion and other functions to ease your editing experience. If you don’t like it, however, you can turn them off. Hack OnThat’s about it. Thanks for listening. I’ll be quiet from now on (unless there’s an update about the app—I’ll remind you for that!). Happy writing! [^emphasize]: If Underlines is turned on, _this notation_ will render as underlined instead of emphasized [^under]: If Underline is disabled _this_ will be rendered as emphasized instead of being underlined. [^quote]: Quote replaces literal &quot; characters with html &lt;q&gt; tags. Quote and Smartypants are syntactically incompatible. If both are enabled, Quote takes precedence. Note that Quote is different from blockquote, which is part of standard Markdown. [^math]: Internet connection required.]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS时间工具类]]></title>
    <url>%2F2017%2F07%2F14%2FiOS%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[iOS时间工具类工作之余写的一个关于Unix时间的工具 12345678910111213141516171819@interface UnixTime : NSObject@property (nonatomic,assign) double unixTimeInterval;//GMT时间戳 微秒级@property (nonatomic,strong) NSDate *unixDate;//GMT时间 2016-01-04 8:55:46 +0000@property (nonatomic,strong) NSString *LocalTimeZone;//本地时区 GMT-12 GMT+12@property (nonatomic,assign) NSInteger timeOffset;//时间偏移量 @property (nonatomic,assign) double unixTimestamp;//GMT+0 毫秒@property (nonatomic,assign) NSInteger unixZeroTimestamp;//当天零点 GMT+0 秒+ (UnixTime *)shareUnixTime;//单例 类方法- (void)getUnixTimestampAtNow;//Unix时间戳 若要获取某天的零时刻 必须先执行找个方法- (void)getSystemTimeZone;//本地时区- (NSString *)getTimeStringWithTime:(double)time;//字符串输出时间 设置日期格式带毫秒的 2016-01-04 16:55:46- (NSInteger)getUnixTimeWithDay:(NSInteger)day;// 某天的零时Unix时间戳- (NSInteger)getUnixTimeWithDay:(NSInteger)day AndClock:(NSInteger)clock; // 某天的特定时刻Unix时间戳- (NSInteger)gettimestampWithDateFormatString:(NSString *)dateFormatString;- (NSString *)formatTimeWithTime:(NSNumber *)time;//根据传入时间数值 返回hh:mm:ss格式的时间 这个是表示时间点的- (NSString *)formatHMWithTime:(NSNumber *)time;//根据传入时间数值 返回hh:mm格式的时间 这个时用来表示时间长短的- (NSString *)getTravelTimeWithStartTime:(NSNumber *)startTime andEndTime:(NSNumber *)endTime;//根据传入时间数值返回时间差值分钟 这个时用来表示时间长短的- (NSString *)getDayHourMinWithTimeStamp:(NSNumber *)time;@end UnixTime.m文件包含方法的具体实现，用法都在.h文件里写了 12345678910111213#import &quot;UnixTime.h&quot;@implementation UnixTime+ (UnixTime *)shareUnixTime&#123; static UnixTime *unixTime = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; unixTime = [[UnixTime alloc]init]; &#125;); return unixTime;&#125; 1234567891011121314151617- (void)getUnixTimestampAtNow&#123; self.unixDate = [NSDate date]; NSLog(@&quot;GMT %@&quot;,self.unixDate); NSTimeInterval time=[self.unixDate timeIntervalSince1970]; self.unixTimeInterval =time; NSString *timeIntervalString = [NSString stringWithFormat:@&quot;%f&quot;,self.unixTimeInterval]; NSLog(@&quot;GMTTimeInterval %@&quot;,timeIntervalString); NSString *micSecondString = [timeIntervalString substringWithRange:NSMakeRange(timeIntervalString.length-6, 3)]; //NSLog(@&quot;micSec %@&quot;,micSecondString); NSInteger micSec = [micSecondString integerValue]; self.unixTimestamp = (NSInteger)time+micSec/1000.000; NSLog(@&quot;GMTTimestamp %ld&quot;,(long)self.unixTimestamp); [self getUnixZeroTimestamp]; [self getSystemTimeZone]; [self getTimeOffset];&#125; 123456789101112- (void)getSystemTimeZone&#123; NSTimeZone *timezone = [NSTimeZone systemTimeZone]; //NSLog(@&quot;timeZone%@&quot;,timezone); NSString *timeAbbreviation = timezone.abbreviation; self.LocalTimeZone = timeAbbreviation; if ([timeAbbreviation isEqualToString:@&quot;GMT&quot;]) &#123; self.LocalTimeZone = @&quot;GMT+0&quot;; &#125; // NSLog(@&quot;TimeZone.abb: %@&quot;,self.LocalTimeZone);&#125; 123456789101112- (void)getTimeOffset&#123; NSString *str1 = [self.LocalTimeZone substringWithRange:NSMakeRange(3, 1)]; NSString *str2 = [self.LocalTimeZone substringWithRange:NSMakeRange(4, self.LocalTimeZone.length-4)]; NSInteger timeZoneOffset = [str2 integerValue]; if ([str1 isEqualToString:@&quot;+&quot;]) &#123; self.timeOffset = timeZoneOffset*3600; &#125;else if ([str1 isEqualToString:@&quot;-&quot;])&#123; self.timeOffset = -timeZoneOffset*3600; &#125; //NSLog(@&quot;timeOffSet %ld&quot;,(long)self.timeOffset);&#125; 1234567- (void)getUnixZeroTimestamp&#123; self.unixZeroTimestamp = (NSInteger)(self.unixTimestamp/86400)*86400; NSInteger days = self.unixZeroTimestamp/86400 ; NSLog(@&quot;GMTZeroTimestamp %ld&quot;,self.unixZeroTimestamp); NSLog(@&quot;days %ld&quot;,days);&#125; 1234567891011- (NSString *)getTimeStringWithTime:(double)time&#123; NSDate *date = [NSDate dateWithTimeIntervalSince1970:time]; NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init]; [dateFormat setDateFormat:@&quot;YYYY-MM-dd HH:mm:ss&quot;]; // 设置日期格式带秒的 2016-01-04 16:55:46 //NSLog(@&quot;date %@&quot;,date); NSString *timeString = [dateFormat stringFromDate:date]; //NSLog(@&quot;time %@&quot;,timeString); return timeString;&#125; 123456789- (NSInteger)gettimestampWithDateFormatString:(NSString *)dateFormatString&#123; NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init]; [dateFormat setDateFormat:@&quot;YYYY-MM-dd HH:mm:ss&quot;]; NSDate *date = [dateFormat dateFromString:dateFormatString]; NSInteger time= [date timeIntervalSince1970]; NSLog(@&quot;time %ld&quot;,time); return time;&#125; 1234567- (NSInteger)getUnixTimeWithDay:(NSInteger)day&#123; NSInteger unixTime = self.unixZeroTimestamp-(day-1)*86400-self.timeOffset; NSLog(@&quot;unixTime %ld&quot;,unixTime); NSLog(@&quot;%@&quot;,[self getTimeStringWithTime:unixTime]); return unixTime;&#125; 123456789101112131415161718- (NSInteger)getUnixTimeWithDay:(NSInteger)day AndClock:(NSInteger)clock&#123;//特定时刻的Unix时间戳 if (clock&lt;0||clock&gt;24) &#123;//为了避免传入数据不正确 进行换算 增强可靠性 clock = clock%24; if (clock&lt;0) &#123; clock=clock+24; &#125;else&#123; clock=clock; &#125; &#125;else&#123; clock=clock; &#125; NSInteger unixTime = self.unixZeroTimestamp-(day-1)*86400+3600*clock;//-self.timeOffset; //NSLog(@&quot;unixTime %ld&quot;,unixTime); return unixTime;&#125; 1234567891011121314151617181920- (NSString *)formatTimeWithTime:(NSNumber *)time&#123; float _time_2 = [time floatValue]; NSInteger _time_1 = [time integerValue]; NSInteger sec = (NSInteger)((_time_2-_time_1)*60); NSInteger hour; NSInteger min; if (_time_1&gt;=1 &amp;&amp; _time_1&lt;60) &#123; min = _time_1%60; return [NSString stringWithFormat:@&quot;%ld:%.2ld&quot;,min,sec]; &#125; if (_time_1&gt;=60) &#123; hour = _time_1/60; min = _time_1%60; return [NSString stringWithFormat:@&quot;%ld:%.2ld:%.2ld&quot;,hour,min,sec]; &#125; return [NSString stringWithFormat:@&quot;0:%.2ld&quot;,sec];&#125; 12345678910111213- (NSString *)formatHMWithTime:(NSNumber *)time&#123; UnixTime *unixtime = [UnixTime shareUnixTime]; NSString *string = [unixtime getTimeStringWithTime:[time integerValue]]; NSArray *firArray = [string componentsSeparatedByString:@&quot; &quot;]; NSString *firstring = firArray[1]; NSMutableArray *secArray = [NSMutableArray arrayWithArray:[firstring componentsSeparatedByString:@&quot;:&quot;]]; [secArray removeLastObject]; return [secArray componentsJoinedByString:@&quot;:&quot;]; &#125; 12345678910- (NSString *)getTravelTimeWithStartTime:(NSNumber *)startTime andEndTime:(NSNumber *)endTime&#123; NSInteger _startTime = [startTime integerValue]; NSInteger _endTime = [endTime integerValue]; NSInteger travelTime = (_endTime - _startTime)/60+1; return [NSString stringWithFormat:@&quot;%ld&quot;,travelTime];&#125; 123456789101112131415- (NSString *)getDayHourMinWithTimeStamp:(NSNumber *)time&#123; NSInteger _time = [time integerValue]; NSDate *date = [NSDate dateWithTimeIntervalSince1970:_time]; NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init]; [dateFormat setDateFormat:@&quot;YYYY-MM-dd HH:mm&quot;]; // 设置日期格式 2016-01-04 16:55:46 //NSLog(@&quot;date %@&quot;,date); NSString *timeString = [dateFormat stringFromDate:date]; //NSLog(@&quot;time %@&quot;,timeString); return timeString;&#125;@end]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS10富文本推送--UNNotificationExtension--基础篇]]></title>
    <url>%2F2017%2F07%2F14%2FiOS10%E5%AF%8C%E6%96%87%E6%9C%AC%E6%8E%A8%E9%80%81--UNNotificationExtension-%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[本文主要讲述如何集成富文本推送的相关扩展，另外还会有文章来详细展开 简介本地推送和远程推送同时都可支持附带Media Attachments。不过远程通知需要实现通知服务扩展（UNNotificationServiceExtension），在service extension里面去下载attachment，但是需要注意，service extension会限制下载的时间（30s），并且下载的文件大小也会同样被限制。这里毕竟是一个推送，而不是把所有的内容都推送给用户。所以你应该去推送一些缩小比例之后的版本。比如图片，推送里面附带缩略图，当用户打开app之后，再去下载完整的高清图。视频就附带视频的关键帧或者开头的几秒，当用户打开app之后再去下载完整视频。attachment支持图片，音频，视频，附件支持的类型及大小 准备工作添加Notification Service Extension在当前工程项目中添加新的Target–&gt; Notification Service先在Xcode 打开你的工程，File–&gt;New–&gt;Target然后添加这个Notification Service Extension： 添加Notification Content Extension在当前工程项目中添加新的Target–&gt; Notification Content先在Xcode 打开你的工程，File–&gt;New–&gt;Target然后添加这个Notification Content Extension： 添加扩展完成这样你的项目中就会有两个Extension Target 设置ServiceExtension Info.plist 添加http协议支持，没错，这里是支持http协议的，不像其他文章说的不支持 ContentExtension Info.plist 设置可以改变 如果不想使用故事版把NSExtensionMainStoryboard替换为NSExtensionPrincipalClass（我这里已经） ServiceExtension基本设置 当前Target的BundleID根据项目主Target的BundleID自动生成 格式”项目主Target的BundleID.-当前Target名称” 例如当前项目BundleID为 com.apple.NotificationDemo，ServiceExtension的名字是NotificationService 那么ServiceExtension的BundleID就是com.apple.NotificationDemo.-NotificationService Automatically manages signing 官方建议勾选 Deployment Target 必须设置为10.0以上，不能设置为10.0以下 ContentExtension基本设置 当前Target的BundleID根据项目主Target的BundleID自动生成 格式”项目主Target的BundleID.-当前Target名称” 例如当前项目BundleID为 com.apple.NotificationDemo，ContentExtension的名字是NotificationContent 那么ServiceExtension的BundleID就是com.apple.NotificationDemo.-NotificationContent Automatically manages signing 官方建议勾选 Deployment Target 必须设置为10.0以上，不能设置为10.0以下 如何使用 首先当前应用需要支持APNS,不支持的自己集成去吧服务器向设备发送通知这个通知消息的格式是有要求的，有以下几点需要注意： aps字段必须要有，不然收不到通知 aps字段下alert字段必须要有，不然也收不到通知 alert字段的值是字符串的时候，不可为空，不然的话你虽然收的到通知，但是是手机除了震动或者声音，没有任何提示 alert字段的值是字典的时候，下面这三个字段必须要有一个，不然和上面一样。就是一句话alert的值必须是可以使用的 mutable-content字段值最好是1，目前没见过其他值 如果你想在iOS10上展示位富文本的推送格式，category字段必须带，值必须在info.plist文件中能找的到的 1234567891011121314 &#123; &quot;aps&quot;:&#123; &quot;alert&quot; : &#123; &quot;title&quot; : &quot;iOS远程消息主标题！-title&quot;, &quot;subtitle&quot; : &quot;iOS远程消息副标题！-Subtitle&quot;, &quot;body&quot; : &quot;longge -body&quot; &#125;, &quot;sound&quot; : &quot;default&quot;, &quot;badge&quot; : &quot;1&quot;, &quot;mutable-content&quot; : &quot;1&quot;, &quot;category&quot; : &quot;Image_Category&quot;, &#125;, &quot;image&quot; : &quot;http://ot260qjni.bkt.clouddn.com/testOne.jpeg&quot;&#125; 上面的测试图片好像不能用了（具体能不能用你们最好测试一下，直接浏览器打开能看到就可以用），我也不知道为啥 你们可以自己去找找先关的图床。]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods的安装]]></title>
    <url>%2F2017%2F07%2F14%2FMac--Cocoapods%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[重新配置gem源替换1gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ 查看1gem sources -l 请确保只有一个gem源—“https://gems.ruby-china.org/” 123*** CURRENT SOURCES ***https://gems.ruby-china.org/]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单封装AFNetworking]]></title>
    <url>%2F2017%2F07%2F14%2FiOS--Custom_AFNetworking%2F</url>
    <content type="text"><![CDATA[由于本人在工作中经常会进行网络请求，实在是不想一直写那段请求代码，就自己封装了一个LiynNet类。其中使用代理完成方法回调。 这里面涉及到了GET/POST方法。废话不多说直接上代码 下面是.h文件的内容:代理回调协议方法 1234@protocol LiynNetDelegate &lt;NSObject&gt;- (void)netFinsh:(id)object;- (void)netError:(id)errorMsg;@end 这里只有一个属性delegate，用于建立代理关系；这里向外暴露了五个方法，其中第一个类方法用来初始化一个网络请求类的实例化对象，这个对象是一个单例对象，因为网络请求对象，不存储数据，只作为一个单纯的工具类，所以这个对象只需要存在一个就可以。 12345678910@interface LiynNet : NSObject@property (nonatomic, weak) id&lt;LiynNetDelegate&gt; delegate;#pragma mark: method+ (LiynNet *)defaultNet;- (void)uploadPOST:(NSString *)URLString Parameters:(id)parameters UploadDictionary:(NSDictionary*)uploadInfo;- (void)POST:(NSString *)URLString Parameters:(id)parameters;- (void)GET:(NSString *)URLString Parameters:(id)parameters;- (void)GETPic:(NSString *)URLString Parameters:(id)parameters Path:(NSString *)path;@end 下面是.m文件的内容创建单例对象 123456789+(LiynNet *)defaultNet&#123; static LiynNet *net = nil; if (net == nil) &#123; net = [[LiynNet alloc] init]; net.manager = [AFHTTPSessionManager manager]; net.manager.responseSerializer = [AFHTTPResponseSerializer serializer]; &#125; return net;&#125; 以下是网络请求在这里我就想了定制，因为有时候需要判断返回数据的类型，例如：当一个页面进行多种数据请求时，代理方法只有一个，那么我们就需要一个标记变量来区别这次返回的数据类型是什么。所以这里的parameters字典里需要一个字段msgType来区别。 一般POST下载请求1234567891011- (void)POST:(NSString *)URLString Parameters:(id)parameters&#123; NSString *msgType = parameters[@&quot;msgType&quot;]; NSLog(@&quot;&#123;\nmethod:POST \nURL:%@ \nParameters:%@&quot;,URLString,parameters); [self.manager POST:URLString parameters:parameters[@&quot;msg&quot;] progress:^(NSProgress * _Nonnull uploadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; [self success:@&#123;@&quot;msgType&quot;:msgType,@&quot;msg&quot;:responseObject&#125;]; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; [self failure:@&#123;@&quot;msgType&quot;:msgType,@&quot;error&quot;:error&#125;]; &#125;];&#125; 一般的GET下载请求1234567891011- (void)GET:(NSString *)URLString Parameters:(id)parameters&#123; NSString *msgType = parameters[@&quot;msgType&quot;]; NSLog(@&quot;method:GET URL:%@ Parameters:%@&quot;,URLString,parameters); [self.manager GET:URLString parameters:parameters progress:^(NSProgress * _Nonnull downloadProgress) &#123; &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; [self success:responseObject]; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; [self failure:@&#123;@&quot;msgType&quot;:msgType,@&quot;error&quot;:error&#125;]; &#125;];&#125; 一般的POST上传请求注意上传的字段是服务器给定的，传入的字典uploadInfo内@”uploadParameter”对应的值。 1234567891011121314151617181920212223- (void)uploadPOST:(NSString *)URLString Parameters:(id)parameters UploadDictionary:(NSDictionary*)uploadInfo&#123; NSString *msgType = parameters[@&quot;msgType&quot;]; NSLog(@&quot;&#123;\nmethod:POST \nURL:%@ \nParametersCid:%@&quot;,URLString,parameters[@&quot;msg&quot;]); NSDictionary *dict = parameters[@&quot;msg&quot;]; [self.manager POST: URLString parameters:dict constructingBodyWithBlock:^(id _Nonnull formData) &#123; NSData *rightData = UIImageJPEGRepresentation(uploadInfo[@&quot;image&quot;], 0.7); [formData appendPartWithFileData:rightData name: uploadInfo[@&quot;uploadParameter&quot;] fileName:@&quot;IDRight.png&quot; mimeType:@&quot;image/jpeg&quot;]; &#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123; NSLog(@&quot;%f&quot;,1.0 * uploadProgress.completedUnitCount/uploadProgress.totalUnitCount); &#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingMutableContainers error:nil]; [self success:@&#123;@&quot;msgType&quot;:msgType,@&quot;msg&quot;:dict&#125;]; &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; [self failure:@&#123;@&quot;msgType&quot;:msgType,@&quot;error&quot;:error&#125;]; &#125;];&#125; 两个私有方法请求数据成功12345- (void)success:(id)responseObject&#123; if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(netFinsh:)]) &#123; [_delegate netFinsh:responseObject]; &#125;&#125; 请求数据失败12345- (void)failure:(id)error&#123; if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(netError:)]) &#123; [_delegate netError:error]; &#125;&#125; 这个类是基于AFNetworking的，所以在使用的时候必须要先倒入AFNetworking的第三方库，建议使用CocoaPods来导入，如果有人不会使用的可以自行百度。1pod &apos;AFNetworking&apos;, &apos;~&gt; 3.1.0&apos; 首先在使用的类里遵循协议 1&lt;LiynNetDelegate&gt; 声明一个全局的LiynNet类的对象（这个全局只是建议 不全局也可以） 123&#123; LiynNet *_net;&#125; 或者定义一个属性 1@property (nonatomic, strong) LiynNet *net; 实例化这个LiynNet对象并建立代理关系 12345678#pragma mark - 懒加载-(LiynNet *)net&#123; if (_net == nil) &#123; _net = [LiynNet defaultNet]; _net.delegate = self; &#125; return _net;&#125; 实现协议的方法在这里你就可以操作返回的数据了123- (void)netFinsh:(id)object&#123; NSLog(@&quot;msgType %@\n msg %@&quot;,object[@&quot;msgType&quot;],object[@&quot;msg&quot;]);&#125; 这里你就需要慢慢查找原因了 123- (void)netError:(id)errorMsg&#123; NSLog(@&quot;msgType %@\n msg %@&quot;, errorMsg[@&quot;msgType&quot;], errorMsg[@&quot;msg&quot;]);&#125;]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水波纹-OC-iOS]]></title>
    <url>%2F2017%2F07%2F14%2FiOS--Water_Ripple_OC%2F</url>
    <content type="text"><![CDATA[简介使用iOS原生CoreGraphic框架完成，主要内容就是在给定的路径上绘制出图形，水波纹的实现是按照三角函数的sin函数来实现的，利用sin函数计算出大量的点，然后做颜色填充。 实现方法首先一个波纹需要一个layer来进行渲染，越底层的波纹要越早绘制，本Demo只实现了双波纹交错。水波纹基本属性： 不需要对外暴露的属性12345678@interface WaterRippleView()&#123; float _currentLinePointY;&#125;@property (nonatomic, strong)CADisplayLink *rippleDisplayLink;//苹果的垂直同步@property (nonatomic, strong)CAShapeLayer *mainRippleLayer;//主波图层@property (nonatomic, strong)CAShapeLayer *minorRippleLayer;//次波图层@property (nonatomic, assign)CGFloat rippleWidth;//波浪宽度@end 可以对外暴露的属性1234567@property (nonatomic, strong)UIColor *mainRippleColor;//主波填充颜色@property (nonatomic, strong)UIColor *minorRippleColor;//次波填充颜色@property (nonatomic, assign)CGFloat mainRippleoffsetX;//主波偏移量@property (nonatomic, assign)CGFloat minorRippleoffsetX;//次波偏移量@property (nonatomic, assign)CGFloat rippleSpeed;//波浪速度@property (nonatomic, assign)CGFloat ripplePosition;//波浪Y轴位置@property (nonatomic, assign)float rippleAmplitude;//波浪振幅 各属性的默认值设置12345678self.mainRippleColor = [UIColor colorWithRed:255/255.0f green:127/255.0f blue:80/255.0f alpha:1];self.minorRippleColor = [UIColor whiteColor];self.mainRippleoffsetX = 1;self.minorRippleoffsetX = 2;self.rippleSpeed = .5f;self.rippleWidth = frame.size.width;self.ripplePosition = frame.size.height-10.0f;self.rippleAmplitude = 5; 对外暴露的方法1234//设置frame 主波填充颜色 次波填充颜色- (instancetype)initWithFrame:(CGRect)frame mainRippleColor:(UIColor *)mainRippleColor minorRippleColor:(UIColor *)minorRippleColor;//设置frame 主波填充颜色 次波填充颜色 主波偏移量 次波偏移量 波浪速度 波浪Y轴位置 波浪振幅- (instancetype)initWithFrame:(CGRect)frame mainRippleColor:(UIColor *)mainRippleColor minorRippleColor:(UIColor *)minorRippleColor mainRippleoffsetX:(float)mainRippleoffsetX minorRippleoffsetX:(float)minorRippleoffsetX rippleSpeed:(float)rippleSpeed ripplePosition:(float)ripplePosition rippleAmplitude:(float)rippleAmplitude; 在view中需要绘制图形时，要在自带的dramRect：方法中编写相关代码123456789101112131415- (void)drawRect:(CGRect)rect &#123; /* *创建两个layer */ self.mainRippleLayer = [CAShapeLayer layer]; self.mainRippleLayer.fillColor = self.mainRippleColor.CGColor; [self.layer addSublayer:self.mainRippleLayer]; self.minorRippleLayer = [CAShapeLayer layer]; self.minorRippleLayer.fillColor = self.minorRippleColor.CGColor; [self.layer addSublayer:self.minorRippleLayer]; self.rippleDisplayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(getCurrentRipple)]; [self.rippleDisplayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];&#125; 下面是绘制代码：主波123456789101112131415- (void)drawMainRipple&#123; self.mainRippleoffsetX += self.rippleSpeed; CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, nil, 0, self.ripplePosition); CGFloat y = 0.f; for (float x = 0.f; x &lt;= self.rippleWidth ; x++) &#123; y = self.rippleAmplitude * sin(1.2 * M_PI/ self.rippleWidth * x - self.mainRippleoffsetX *M_PI/180) + self.ripplePosition; CGPathAddLineToPoint(path, nil, x, y); &#125; CGPathAddLineToPoint(path, nil, self.rippleWidth, self.frame.size.height); CGPathAddLineToPoint(path, nil, 0, self.frame.size.height); CGPathCloseSubpath(path); self.mainRippleLayer.path = path; CGPathRelease(path);&#125; 次波123456789101112131415- (void)drawMinorRipple&#123; self.minorRippleoffsetX += self.rippleSpeed+0.1f; CGMutablePathRef minorRipple = CGPathCreateMutable(); CGPathMoveToPoint(minorRipple, nil, 0, self.ripplePosition); CGFloat y = 0.f; for (float x = 0.f; x &lt;= self.rippleWidth ; x++) &#123; y = self.rippleAmplitude * sin(1.2 * M_PI/ self.rippleWidth * x - self.minorRippleoffsetX*M_PI/360 ) + self.ripplePosition; CGPathAddLineToPoint(minorRipple, nil, x, y); &#125; CGPathAddLineToPoint(minorRipple, nil, self.rippleWidth, self.frame.size.height); CGPathAddLineToPoint(minorRipple, nil, 0, self.frame.size.height); CGPathCloseSubpath(minorRipple); self.minorRippleLayer.path = minorRipple; CGPathRelease(minorRipple);&#125; 实现效果 最后本Demo的git库地址：https://git.oschina.net/LiynXu/waterripple.git欢迎访问]]></content>
      <tags>
        <tag>原创分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac--Xcode下载地址大全]]></title>
    <url>%2F2017%2F07%2F14%2FMac--Xcode%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Xcode下载——绝对的官方地址不建议使用迅雷下载，因为这货下载不下来，建议使用浏览器自带的下载器 不建议使用迅雷下载，因为这货下载不下来，建议使用浏览器自带的下载器 不建议使用迅雷下载，因为这货下载不下来，建议使用浏览器自带的下载器 下载方式简单粗暴： 第一种、点击Xcode版本名称稍等几秒即可开始下载 另一种、右键复制链接地址，打开下载软件，新建任务把复制的链接粘贴在地址输入框即可开始下载 本文中涉及到的下载地址均为苹果官方下载地址 Xcode 2Xcode_2.3.dmg 915.0MB Xcode_2.4.dmg 938.2MB Xcode_2.4.1.dmg 923.2MB Xcode 3Xcode_3.0.dmg 1.1GB Xcode_3.2.dmg 748.7MB Xcode_3.2.3_and_ios_sdk_4.0.1.dmg 2.2GB Xcode_3.2.3_and_ios_sdk_4.0.2.dmg 2.4GB Xcode_3.2.4_and_ios_sdk_4.1.dmg 2.9GB Xcode_3.2.5_and_ios_sdk_4.2.dmg 3.5GB Xcode_3.2.6_and_ios_sdk_4.3.dmg 4.1GB Xcode 4Xcode_4_and_ios_sdk_4.3.dmg 4.2GB Xcode_4.0.1_and_ios_sdk_4.3.dmg 4.2GB Xcode_4.0.2_and_ios_sdk_4.3.dmg 4.2GB Xcode_4.1_for_snow_leopard.dmg 4.3GB Xcode_4.1_for_lion.dmg 2.9GB Xcode_4.2_for_snow_leopard.dmg 1.6GB Xcode_4.2_for_lion.dmg 1.6GB Xcode_4.2.1_for_lion.dmg 1.6GB Xcode_4.3_for_lion.dmg 1.4GB Xcode_4.3.1_for_lion.dmg 1.4GB Xcode_4.3.2_for_lion.dmg 1.8GB Xcode_4.3.3_for_lion.dmg 1.8GB Xcode_4.4.dmg 1.8GB Xcode_4.4.1.dmg 1.8GB Xcode_4.5.dmg 1.5GB Xcode_4.5.1.dmg 1.5GB Xcode_4.5.2.dmg 1.5GB Xcode_4.6.dmg 1.6GB Xcode_4.6.1.dmg 1.6GB Xcode_4.6.2.dmg 1.6GB Xcode_4.6.3.dmg 1.6GB Xcode 5Xcode_5.dmg 1.9GB Xcode_5.0.1.dmg 2.0GB Xcode_5.0.2.dmg 2.0GB Xcode_5.1.dmg 2.1GB Xcode_5.1.1.dmg 2.1GB Xcode 6Xcode_6.0.1.dmg 2.1GB Xcode_6.1.dmg 2.5GB Xcode_6.1.1.dmg 2.5GB Xcode_6.2.dmg 2.5GB Xcode_6.3.dmg 2.5GB Xcode_6.3.1.dmg 2.5GB Xcode_6.3.2.dmg 2.5GB Xcode_6.4.dmg 2.6GB Xcode 7Xcode_7.dmg 3.5GB Xcode_7.0.1.dmg 3.5GB Xcode_7.1.dmg 4.2GB Xcode_7.1.1.dmg 4.2GB Xcode_7.2.dmg 4.4GB Xcode_7.2.1.dmg 4.4GB Xcode_7.3.dmg 4.8GB Xcode_7.3.1.dmg 4.8GB Xcode 8Xcode_8.xip 4.1GB Xcode_8.1.xip 4.1GB Xcode_8.2.xip 4.2GB Xcode_8.2.1.xip 4.2GB Xcode_8.3.xip 4.1GB Xcode_8.3.1.xip 4.1GB Xcode_8.3.2.xip 4.1GB Xcode 9Xcode_9.xip 5.0GB Xcode_9.0.1.xip 5.0GB Xcode_9.1.xip 5.0GB Xcode_9.2.xip 5.1GB Xcode_9.3.xip 4.8GB Xcode_9.4.xip 4.8GB Xcode_9.4.1.xip 4.9GB Xcode 10Xcode_10.xip 5.4GB]]></content>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[中国获得了这么多的世界第一，而我们都不知道！]]></title>
    <url>%2F2015%2F12%2F28%2F%E4%B8%AD%E5%9B%BD%E8%8E%B7%E5%BE%97%E4%BA%86%E8%BF%99%E4%B9%88%E5%A4%9A%E7%9A%84%E4%B8%96%E7%95%8C%E7%AC%AC%E4%B8%80%EF%BC%8C%E8%80%8C%E6%88%91%E4%BB%AC%E9%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%EF%BC%81%2F</url>
    <content type="text"><![CDATA[小编终于明白为什么西方国家如此仇视我们了，因为他们饿，他们饿，饿！！ 一、人均蔬菜世界第一 我国蔬菜面积达到3亿多亩，年产量超过7亿吨，人均占有量500多公斤，均居世界第一位。大家可以想一下明天自己家餐桌上有多少蔬菜。大概就没有中国人不吃的“草”！秋葵苦瓜香菜青菜甚至各种叫不出名字的野菜。。。无论是请清炒凉拌炖汤煮粥。。几乎无所不能！ 二、人均鹅肉消费 全球2009年肉鹅出栏量6.47亿只，其中中国出栏6.05亿只，占世界总出栏量的93.5%，占亚洲出栏量的99.2%。2009年，中国鹅肉产量约148万吨，产值约350亿元，占全球产量的94.36%，而欧盟占2.56%，非洲为2.18%。西方人是爱吃鹅肝的，而鹅肝酱更是被誉为西方三大美食之一。 然而中国人吃掉了全世界95%的鹅。（大陆还是鹅肝的主要出口国 = =） 不过这个也实在没办法，毕竟我们吃起鹅来，那方法实在太多了。 鹅肝我们也吃啊，可以做凉菜，小编就很爱卤水鹅肝。 还能做浇头。 但是我们更多的是吃鹅肉啊！那吃法就太多了！！！说起来鹅身上几乎所有的部位咱们都吃啊！道道都是美味！烧鹅(ˉ﹃ˉ) 白切等等等等。。小编相信各个地方，那都有自己的一套吃鹅的菜！ 三、人均鸭肉说到鹅，我们不能不提到鸭子，相信各个地方的基佬们，都有各自不同的吃鸭子方法。 2009年我国鸭存栏 7.71亿只，占世界存栏量的65.73%；出栏20.21亿只，占世界出栏量的76.64%；生产鸭肉265.81万吨，占世界鸭肉总产量的 69.12%。 正义的鸭血粉丝汤！ 毛血旺！ 真的，火锅里不点鸭血，小编觉得这顿就没吃啊有木有！ 但是果然！！不能少了鸭脖鸭头鸭爪鸭肠各种卤味啊！ 北京烤鸭表示舍我其谁！ 南京的盐水鸭简直正义到飞起！ 问：中国的人口占世界20%不到，鸭肉产量占世界70%，人均鸭肉消费是世界其余国家平均的多少倍？ 四、人均水产产量与鸭肉类似，2012年，我国水产养殖占世界70%，2014年提高到74%。 中国人口占世界19%，水产产量占74%，请问中国人均是世界平均的多少倍？ 都闪开！让我这个喜欢吃海鲜的人先说！小编走过这么些的国家，没见过比中国人还会吃海鲜的了！（日本？不不不不，日本也就刺身了，然而生吃这玩意，我朝古代就有了） 最原汁原味的吃法，那必须是清蒸！撒点姜丝葱花，加点老酒，中国人发明的去腥法绝对领先世界NNNN年！那鲜味儿统统都保留住了！ 接着就是人民群众最爱的烧烤！鱿鱼扇贝大虾等等，真是说说小编就流口水！ 更别提还有各种爆炒！煲汤！啧啧啧！ 五、人均红薯连续介绍三种肉类，来点素菜换换口味。 接下来我们介绍世界第七大粮食作物——红薯。 红薯是一种外来作物，最早是由哥伦布从美洲带回欧洲，再逐步传入中国。2011年，中国的红薯产量就占了全世界81.7% 红薯怎么吃？ 冬天必吃的烤红薯啊！！ 暖胃的红薯粥！ 红薯片和红薯干作为零食有多好吃我根本难以形容！全天然零食无添加！ 香甜软糯的红薯球简直就是甜点中的佳品！ 而红薯在中国最大的作用是制成淀粉类食品——粉丝！红薯粉能好吃到我哭出来QAQ没吃过酸辣粉的人生该是多么的悲惨！！ 各种各样的红薯粉做出来的都超级好吃！那Q弹！ 六、人均桃子 桃子是我国的传统作物，在华夏大地广泛种植，并深受世界各国人民欢迎。中国的桃子产量占世界6成，可见国人之爱吃桃子，毕竟连神仙都是吃桃子活命的！ 而中国的桃子品种太多了！你是喜欢吃大蜜桃呢还是油桃呢？是脆桃还是面桃？这也是撕逼一大难题啊！反正小编都喜欢！ 桃子的吃法也多啊！直接洗干净了吃！还可以做成桃子罐头！黄桃罐头是所有罐头里最好吃的不服来辩！ 在南方的一些省份，桃子是可以拿来做菜的。 七、人均柿子 还记得中华小当家里的柿子青椒炒肉丝吗！ 如果说桃子是世界的名水果，那柿子可以算中国的特产了。没错，中国柿子的年产量在200万吨以上，全世界80%的柿子是中国出产的。 柿子可以生吃，我会告诉你你是吃脆柿子还是软柿子也是一大撕逼难题么！！中国各地的柿子，品种不要太多！味道也各不相同！ 柿子还可以做成酱，也可以晒成柿饼（柿饼的做法和口味根据地方不同也是差异很大）。 据说，东北人吃掉的冻柿子可以绕地球一圈。 用柿子做菜就更不是什么大事儿了。 八、人均西瓜你没有看错，我说的就是西瓜。西瓜是少数能亩产万斤的农作物之一。 目前真正可以非试验田亩产上1万斤的农作物有：西瓜、冬瓜、蜜橘、土豆、红薯、萝卜、大白菜、葡萄、南瓜、洋葱！上述农作物的亩产纪录全部由中国农民保持，为伟大的中国农民点赞！ 2012年，世界西瓜产量为9521.1万吨，中国为7000万吨，占7成以上。想想日本等国家那贵到哭的西瓜物价，在看看我天朝那几毛钱一斤的西瓜价。。我都心疼农民们！ 当然别怀疑，咱们西瓜都是能做菜的！ 还有西瓜果冻呢！ 没记错的话，西瓜酱还上过舌尖上的中国！ 九、人均黄瓜 数据比较老，全世界黄瓜5千多万吨，中国生产4千多万吨，是第二名的20多倍。 黄瓜的做法。。。我简直就懒得说了！生吃凉拌拍蒜清炒鸡蛋还有煲汤等等！国民凉菜这称呼我给满分！ 十、人均鸡蛋我国是全世界鸡蛋生产第一大国，连续二十余年人均占有量位居世界第一，2012年中国鸡蛋产量占世界鸡蛋产量43.88%。（2013年上升到45%，2014数据未查到）注：美国人均鸡蛋消费260枚，约11kg，被中国远远甩在身后。 讲真，这么万能的鸡蛋，外国人的吃法实在是。。。太简单且无聊了。。 在中国，吃法千变万化曾经玩坦克世界，有个家伙叫【鸡蛋炒一切】，这个ID已经代表了鸡蛋的地位！ 台湾人觉得咱们吃不起的茶叶蛋！ 外国人眼中满满恶意的皮蛋！小编对皮蛋简直爱到不行啊！什么剁椒皮蛋、皮蛋瘦肉粥、皮蛋拌豆腐都是真爱！ 洋葱黄瓜西红柿青椒韭菜梅干菜等等，没有什么是鸡蛋不能炒的！别忘了，蛋炒饭可是中国料理界的顶端！ 没有什么不能放的蒸蛋！ 十一、人均苹果亚当夏娃吃了苹果，学会了啪啪啪牛顿吃了苹果，发现了万有引力定律图灵吃了苹果，自杀了 乔布斯吃了苹果，开始卖手机 苹果是什么？苹果是水果之王！ 一天一苹果，医生远离我！这话不是乱说的！今天圣诞，你吃苹果了么！ 咱中国农民，就是那水果的父王！我会告诉你，陕西一个省的苹果产量，就可以排世界第一？ 至于苹果什么吃？ 拜托，只是当做是水果吃。。。就种类多到炸了好么？ 十二、猪肉十大猪肉生产国，你只要能看懂China就够了。 2014年全球猪肉总消费1.1亿吨，中国产量占52%！ 已知中国人口占世界19%，请问中国人均吃掉的八戒，是其他国家平均的几倍？ 经验告诉我们，中国有14亿人口，比人均是比不过外国的。但当某项产品的产量超过世界上其他200个国家总和的时候，此法则不再有效。 而中国人民对猪肉的吃法。。。呵呵。请让小编我做出一个藐视全球的表情。 猪！浑身上下！就没有不能被咱们国人吃的！ 猪头肉！正义的下酒菜！ 没有什么！是一顿红烧肉不能抚慰的！ 再不济还有猪蹄呢！！ 红烧大肠（或者猪肠粉和面）都好吃的不得了！ 就算是其他人不要的猪骨头，也能熬出一锅冬日必备的汤！ 十三、人均吃梨梨也是中国本土作物之一，东汉的孔融就出了名的不喜欢吃梨！ 然而全世界2358万吨，中国1732万吨，是外国的3倍。 梨性质温和，做法也很多，多吃对人体极为有利。 送大家一个网址：梨的做法大全，你会感觉新世界被打开了。http://pp.pcbaby.com.cn/photo/26302.html 比较传统的吃法是炖，小编小时候嗓子不好，就吃冰糖炖雪梨！ 十四、人均吃番茄 先给大家看一则新闻：记者实地探访新疆番茄生产 产量占全球四分之一新疆产量占全球四分之一产量占全球四分之一占全球四分之一http://country.cnr.cn/market/20150810/t20150810_519494955.shtml一个省吊打全世界其余所有国家，渣渣。 番茄古代称“狼桃”，味道酸甜，营养丰富，生津止渴。它是典型的外来作物，也是西方国家的主力蔬菜水果，然而产量依旧被中国吊打，没什么卵用。它可以炖牛腩，可以炒鸡蛋，可以凉拌，也可以生吃，几乎没有什么禁忌。小编高兴了还当水果吃╮(╯▽╰)╭ 至于番茄到底是蔬菜还是水果。。。这种事有意义？ 十五、人均吃茄子 原产阿拉伯，但是古代茄子有毒，经过千百年的改良种植，才有了今天的美味。。。我天朝人民对吃的真的太尼玛执念了！从下表可以看出，除了中国，茄子前十名几乎都是中东国家，然后才是欧洲国家。世界总产量4千多万吨，中国2千8百万吨，占三分之二以上。 茄子吃法也多了！红烧茄子超级下饭！ 小编喜欢烤茄子！ 肉末茄子的正义大家懂的！ 炸茄子也是一道名菜！ 茄子先清蒸熟，然后撕成条状，再用麻油等香料拌一拌！美味！ 十七、人均吃花生有很多人说：楼主你贴的都是外国人不吃的，先不论我已经列出的鸡蛋、西红柿在洋人餐桌上的地位，下面我要举得例子，绝对是重量级的。 它就是花生。 所有西方国家，只要是吃面包的，谁敢说自己没吃过花生酱？ 花生原名【落花生】，原产自南美洲，后来中国人简称它为【花生】，越南人则称之为【落】。清代的《滇海虞衡志》记载:落花生为南果中第一。 意思就是：你们搞的这个花生啊，亦可赛艇！（自己翻译成英文） 咱们中国吃花生，吃法不说上千种，几百种是有的，常见的有： 花生糖 花生酥 单独可以做零食来吃~油炸花生米就是下酒利器！ 这种裹了糖粉的花生好吃的不得了！ 小平同志戒烟的时候，就靠着吃鱼皮花生熬烟瘾。 作为配菜就更多了，什么宫保鸡丁！花生莲藕排骨汤等等！ 南昌特色，猪肺花生汤！ 2012年中国花生产量16.7万吨，占全世界42%。 中国人均是美国的1.3倍，是印度的20倍，是世界平均的2倍以上。 一听啤酒，一盘油炸花生米就是一个惬意的晚上，这种情调，才是生活啊。 十八、人均吃鱼中国是一个大陆国家，海岸线长度仅仅是菲律宾的一半，印尼的三分之一，加拿大的十二分之一。中国是一个人多缺水的国家，领土水域率仅2.8%……我们既没有日本的四面环海，也没有俄罗斯背靠三大洋，更没有英法美遍布全球的海外自制领。但是我们有勤劳的中国渔民。 所以我们的鱼肉产量是第二名的5.5倍，是印度8倍，是美国的10倍 中国人吃的鱼种类不要太多！ 中国人做鱼的方式简直不要太讲究！ 中国人做的鱼简直不要太好吃！ 海鱼河鱼、红烧清蒸油炸醋溜乱炖煲汤油煎腌制……只是说到鱼，小编就可以说上三天三夜！ 各种各样的鱼干，鱼丝儿也超级正义！ 十九、人均吃鲍鱼2010年， 全世界鲍鱼产量3万吨，中国占2.3万吨左右，其中，福建占3/4。 中国人吃掉全世界一大半的猪肉，三分之二的鱼肉，五分之四的鲍鱼，居然有人说中国人喝不起牛奶？？ 事实上这个真的不怪牛奶，牛奶说我不背这个锅。 中国人普遍乳糖不耐受是事实，而对于小编来说。。。我真心不爱喝啊！捶地！这是习惯问题啊，再好的奶对我来说都不如一杯热豆浆来的正义！ 二十、人均吃菠菜菠菜是唐朝传入中国的古老蔬菜，也是西方国家的主食蔬菜之一。 美国漫画大力水手中的菠菜形象深入人心啊！ 然而中国菠菜产量是全世界90%。你没有看错，就是90%。中国菠菜是剩下195个国家产量之和的九倍。什么是吊打，这就叫吊打。 小编表示吃火锅一定要来菠菜的！ 清炒菠菜上汤菠菜也是超级清爽可口啊~ 菠菜猪肝简直绝配！ 菠菜饺子最近也很流行~ 二十一、人均吃蘑菇培根吊打西方、鸡蛋吊打、西红柿吊打、菠菜吊打、鱼肉吊打、花生酱吊打，外国人还吃什么？嗯，他们还吃蘑菇。几乎所有的西方文学作品、美剧英剧、漫画小说里都有蘑菇。奶油蘑菇汤什么的算是西餐的必备了。 然而中国食用菌产量占世界总产量70%。 中国菌农：你也配姓赵？ 小编觉得只要云南人站了出来就够了！！你知道云南蘑菇多到云南人都会吃错么？你知道云南每年因为蘑菇中毒造成幻觉谜一样体验的小伙伴有多少么？嚯嚯！ 烧烤！ 清炒！ 炖肉！ 云南的菌菇火锅我能推一辈子！ 十六、人均吃板栗请先看一篇奇文：《中国板栗,请在良种和机械上下功夫》文章节选：“作为板栗生产大国,我国板栗年产195万吨,仅占世界板栗年产量的84%，中国尚不能说是板栗产业强国。 ” 仅占84%！占84%！84%！多么的振聋发聩，多么的痛心疾首！仅占84%！我大清已耕战立国，怎么能仅占84%呢？我感到深深地忧虑。我国这是药丸啊。 所以说同志们，我们还需努力啊！ 冬天了，糖炒栗子可以吃起来了！！！ 二十二、人均核桃老规矩，先读文章：《中国核桃年产量83万吨 居世界前列》 http://news.sina.com.cn/o/2010-09-29/195418178892s.shtml 我一看标题：据世界前列？难道还有国家比中国核桃还多？仔细一看，果然，2006年全世界核桃收获面积67.29万公顷，总产量170万吨。世界核桃170万吨，中国才83万吨，外国有87万吨，妥妥的落后于外国啊。中国绝不屈服！于是中国农民奋发图强！2008年83万吨，2009年98万吨，2013年达到142万吨！ 终于，在2014年，中国核桃产量达到外国的2倍，不用再吃青果丸了。 核桃么，你是吃小核桃还是大核桃？ 核桃酥简直就是中国言情古装小说必备了(ˉ﹃ˉ) 日食核桃三百颗，不辞长作陕西人！ 核桃，那也必须是可以炒菜的！ 二十三、人均吃虾“发达国家”继鱼肉、菠菜、花生酱、番茄、鸡蛋、蘑菇被中国吊打之后，我们来介绍一下中国人均吃虾~早在80年代，中国的虾肉产量就是世界第一！2013年，中国虾肉产量153万吨，占全世界的47.8%，而到了2014年，居然出现了《产量过高导致中国的虾价下跌30-50%》的消息。。。 可能是中国人已经吃掉了世界一半的鸡蛋，一大半的猪肉，三分之二的鱼肉，十分之七的蘑菇，五分之四的鲍鱼，84%的板栗和90%的菠菜等等。。。。。。实在吃不下了…… 那咱们吃虾，那也是，啧啧！别管是海里的还是河里的，各有吃法！ 醉虾！根据大小不同，不仅仅是醉的方式，就是味道也是不一样！ 广州的虾饺就不用说了！鲜虾烧麦也好吃！ 火锅里的虾滑！必须点！ 其他各种各样的虾！对虾！河虾！白水虾！北极虾！ 还有很多悲催的所谓的外来侵略动物。。。。比如小龙虾。。反正到最后不禁被中国人民发现了吃法，还开始了养殖来吃。。一盘麻小，足以！ 二十四、人均吃杨梅杨梅在我国自然生长有7000多年历史，人工栽培已有2000多年，是江南名果之一。杨梅是彻彻底底中国水果，可能日本有种植一点，但和莲子、荸荠、菱角、枇杷、李子这些水果类似，中国的产量接近全世界的100%以至于台州日报（杨梅主产地）发出文章（挑衅）：《杨梅只产在中国吗？》《杨梅只产在中国吗？》《杨梅只产在中国吗？》 http://paper.taizhou.com.cn/tzrb/html/2015-06/25/content_627010.htm 天涯上更是有位ID叫“小桥下的鱼儿”的小伙伴提问：【现在世界上哪里有新鲜杨梅买？】 http://wenda.tianya.cn/question/65cd2ca6af7e4ba3 杨梅简直是小编最爱的水果之一了！！除了生吃之外，杨梅酒简直人间极品！小编家里年年都会自制好几坛子！ 喝不了酒的，冰镇杨梅汁也不错。 杨梅罐头也正义！ 盐津杨梅也是零食必备！ 我国伟大诗人苏轼曾写道：新居未换一根椽，只有杨梅不值钱。莫共金家斗甘苦，参寥不是老婆禅。产量超过全世界90%，就是这么任性。 二十五、人均吃杏子、杏仁杏子是中国的传统水果，孔子讲课的地方就叫【杏坛】，而杏仁是杏的种子，分为甜杏仁和苦杏仁。 注：美国加州大杏仁是扁桃仁，不是杏仁，属于翻译错误。 老规矩，先看一则旧闻：《喀什杏子产量世界第一》2003年8月。 http://www.ts.cn/GB/channel3/100/200308/29/40126.html 提示一：喀什市是新疆的一个市提示二：喀什并不是中国杏子的主产地提示三：这篇文章写于2003年 虽然中国一个市就能坐上世界第一，但中国的杏子产量还是以每年15%~20%的速度增长，2007年中国鲜杏和杏浆产量超过世界50%，2014年已接近四分之三。甚至环球网刊登出对世界第二的羞辱性文章：《澳大利亚成全球第二大杏仁生产国》。 http://china.huanqiu.com/News/mofcom/2014-11/5197314.html 杏子是利用率非常高的农作物，鲜果可以榨杏浆，杏浆可以做果汁~小编自己特别喜欢生吃！ 杏子罐头一般都是外贸出口了，国人可以吃到的水果罐头太多，杏子并不具有优势。 杏肉晒干了就超级好吃！ 杏仁的做法就更多了！咱们老祖宗用杏仁做甜品简直了！杏仁酥、杏仁饼、杏仁豆腐、杏仁露、杏仁茶等等！ 二十六、人均吃人参美国又叫花旗国。那是不是美国人参就叫花旗参呢？西洋参原产于加拿大的大魁北克与美国的威斯康辛州，中国北京怀柔与长白山等地也有种植。加拿大产的叫西洋参，美国产的叫花旗参，服用方法分为煮、炖、蒸食、切片含化、研成细粉冲服等。 中国不仅有西洋参的种植，更多地是传统人参的栽培和采集。中国的吉林省白山市，人参产量是外国的两倍半。详见：《白山市打造世界人参之都 人参总产量占世界70%》http://jl.sina.com.cn/news/interview/2013-08-29/063640466.html咱们不屑于拿省和美加比，地级市足矣。 咱们中国吃的参各种各样的。。。 有用来泡茶做药的！ 也有拿来炖鸡的。 人参炒虾仁。 二十七、茉莉花举了那么多肉类菜类水果类，我们喝点茶吧。 茉莉花是菲律宾、突尼斯、印尼三个国家的国花,象征着爱情和友谊。在过去的五年里，茉莉花的旋律传遍了中南海和三百加一的每个角落。 一般我们用茉莉花泡茶！ 云南有一种鲜花饼，非常好吃，也有用茉莉做馅的！ 拿来烧豆腐也还能接受！ 还可以炒鸡蛋。。鸡蛋果然是万能的！ 最后是产量报告：《广西横县茉莉花产量占世界总产量的60%》！ 二十八、蚕豆蚕豆又叫罗汉豆，胡豆。世界上最早的蚕豆遗骸是在死海北面的古城杰利科遗址中发现有公元前6250年的蚕豆残存物，距今已有8千多年历史了。 一般认为蚕豆起源于北非。关于蚕豆没什么可说的，我国有40多个栽培品种，上世纪50年代产量就达到世界第一，连续65年稳稳不动。现在产量接近世界的全部了吧。。。吃法就更多了。 凉拌一下就能吃。 也有鱼香蚕豆的做法！ 香酥蚕豆也是下酒必备菜！（就是炸一炸） 蟹黄也不错。 各种蚕豆汤也是非常赞~ 二十九、荔枝说起荔枝，就有说不尽的传说和故事。 2011年茂名荔枝产量近45万吨，约占广东省荔枝产量的一半，占中国荔枝产量的1/4，占世界荔枝产量的1/5。问：中国荔枝占全球多少？ 答案就在2002年新华网的一篇文章里：《中国荔枝产量不断刷新纪录 产量占全世界的80%》 荔枝生吃就很赞了。罐头也不错~ 蘸酱油其实真的很好吃！ 一骑红尘妃子笑，无人知是荔枝来。 日啖荔枝三百颗，来世还做中国人。 三十、吃大蒜 大蒜原产地在西亚，自汉代张骞出使西域，把大蒜带回国安家落户，至今已有两千多年的历史。大蒜在美剧里的出镜率还是很高的（防治吸血鬼特效药） 中国大蒜看山东 ，山东大蒜看金乡中国的金乡县大蒜产量占全世界60% 对，就是金乡县，一个64万人口，0.08万平方公里的小县城。该县人民已经大蒜选种理论 V大蒜育苗理论 V土壤检测学说 V。。。。。。大蒜库存管理 V 大蒜生吃比较少，但是也有糖蒜、腊八蒜！好吃！ 烤大蒜小编到没怎么吃过。。。 作为中国人民不可缺少的调味料！几乎所有菜都能放大蒜和蒜苗。。。太普通以至于被忽略了——其实大蒜是主要的抗癌食材。 三十一、枣 先科普一下：中国的大枣是鼠李科，伊朗的椰枣是棕榈科。 国际贸易中，中国的大枣、红枣、冬枣统称为【枣果，jujube】伊朗的椰枣就叫【椰枣，date（就是约会的英文词）】。 枣原产中国，有文字记载的栽培历史达三千多年。在中国历史上，枣与桃、杏、李、栗一起，并称为“五果”。世界各国栽培的枣均引自我国。 枣是中国的特有果树，也是世界上枣的最大生产国和枣产品唯一出口国。 我国枣虽然年产100万吨，但年出口量仅800-1000吨。世界市场上90%以上枣靠我国供应。 小编超级喜欢吃冬枣！ 但是果然新疆的枣真心好吃啊！ 除了直接吃，泡茶，还各种可以做菜！ 腌渍一下就啧啧！ 枣泥简直太正义！各种中式甜点都少不了它啊~ 三十二、贝类 中国具有悠久的贝壳捕捞和养殖历史，远古时期，贝壳是我国的货币。 我国是世界上最大的贝类养殖国，贝类增养殖已经成为沿海海水养殖业的支柱之一。 我国贝类年产量占世界贝类总产量的60%以上，其中扇贝的年养殖产量最高，占世界扇贝类年养殖产量的80%以上。 据统计，2011年，我国贝类养殖产量为1266.65万吨，其中牡蛎375.63万吨，扇贝130.61万吨，蛤361.33万吨，贻贝70.74万吨，蛏74.48万吨，鲍7.68万吨。 山东人吃蛤仔，都是辣椒爆炒，用脸盆装着吃，一脸盆一脸盆的吃。在青岛，这样一小盘如果卖30块钱，就可以断定是黑店了 扇贝的吃法是加上蒜蓉和粉丝 淡菜咋吃都行！ 因为蒸着吃蛏子更胜一筹，而且蛏子超级便宜，4元一斤？ 不建议大家吃海鲜全宴，容易尿酸超标，吃个意思就行，过犹不及 这一桌东西看着吓人，其实青岛随便一个饭店，甚至夜市摊子，都能给你做出来，随时都有。 三十三、银耳 银耳又就是白木耳。中国的食用菌类产量占世界70%以上，其中银耳的产量占全世界90%以上，被誉为是中国的“菌中之冠” 详见：《福建古田银耳正式挂牌上市 占世界银耳总产量90%》 http://news.cnr.cn/native/city/201404/t20140428_515387273.shtml 银耳发源于四川，而胡建人将之发扬光大。 下图是福建古田（世界银耳90%产地，古田对银耳拥有最终解释权） 古田银耳。 银耳富含植物胶质，性温良，男女老少皆宜，古时候被称为“长生不老药” 银耳一半是和红枣、莲子、燕窝一起炖着吃，这四种食材中国的产量都接近100%。 换言之，没有中国人的地方，你是吃不到的。 银耳夏天可以消暑，冬天可以温补，曾经学校有韩国留学生，班级宴会散场时，每人面前有银耳羹一盅作为甜品，惊呼此为何物，答【此物是大长今里的韩国特产，你不知道叫啥吗？】 掌声经久不息。 三十五、人均生姜 生姜原产自东南亚，全世界各地都有种植，姜饼是古罗马人的传统美食。 意大利姜饼(Lebkuchen) 德国姜饼 姜饼上写着圣诞快乐，可见生姜是欧洲人的传统过年食品。 西方文学作品中常见到【姜饼小屋】，体现出老欧洲人对生姜的深深眷恋。 欧洲湿冷，吃生姜可以祛湿御寒，发汗活络。 但生姜在中国餐桌上的地位不言而喻，毕竟它可是2015年最佳coser！它COS的肉，你一定吃到过！ 中国生姜产量占世界53%，排在世界第二的是山东省平度市。 资料：http://district.ce.cn/zg/201110/24/t20111024_22782846.shtml 生姜种类很多，性质各不相同，有的药性猛烈，有的较温和，做成姜汤服用之前，一定要区分品种。 配合红枣，适合妹子补身体。 姜糖（苦味） 姜糖（甜味） 四川的子姜闻名天下，子姜牛肉丝，姜爆鸭子都是川菜馆常见的选项。 小编去泉州吃过姜母鸭也超级赞！ 姜汁皮蛋也是常见的小菜： 目前呢，这帖子就更新到这里了！ 小编找了很多的图也补充了很多的菜，写到这里感觉自己已经要饿死了！ 总结一下就是：咱们中国人吧，占世界20%的人口吃掉了全世界42%的花生、45%的鸡蛋、 48%的虾、52%的猪肉、 60%的桃子 、60%的苹果、60%的核桃 、70%的梨、 70%的鸭、70%的食用菌 、70%的人参 、70%的西瓜、 74%的水产、75%的鲍鱼、75%的杏子 、80%的荔枝、81%的红薯、 84%的板栗、 90%的枣子、90%的菠菜、95%的鹅、100%的杨梅。 要知道，中国进口的大宗商品里面除了石油和矿产，接下来就是农产品了！ 是的，我们虽然无数产量都是世界第一，但是我们不出口！！我们内销！（自己都不够吃呢！有时候还要进口！） 而只要中国进口出现一点点问题，世界农产品价格就会出现了大幅度波动，当年世界粮食危机很多西方媒体就指责中国需求量扩大导致了全球粮食价格上涨……囧。。。 而有些国家，甚至为了中国人民的吃，彻底改变了自己的农业结构，比如阿根廷，开始是牛肉出口国，现在都改种大豆了。。为啥？因为中国人要用大豆养猪啊。 拿到那么多的第一，其实人口基数是一部分原因，而且世界上很多地方作为主要食物的五谷土豆鸡肉牛羊肉并不在列，与其说中国人吃得多，不如说中国人的食谱广，懂得利用一切可利用的食材资源，吃货帝国之所以是吃货帝国，不仅仅是因为能吃，还因为会吃！ 从吃的角度看，世界上只有两个国家：中国和外国。 顺便感叹下，外国那50多亿人，整天都在吃什么东西啊。。。]]></content>
  </entry>
</search>
